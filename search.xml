<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring 框架概述]]></title>
    <url>%2F2019%2F04%2F28%2FJava%2FSpring%2F2019-04-28%2F</url>
    <content type="text"><![CDATA[核心 Ioc 控制反转 AOP 面向切面编程 Ioc控制对象： * 对象的依赖 = DI(依赖注入)]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 进阶-ResultMap]]></title>
    <url>%2F2019%2F04%2F11%2FJava%2FMybatis%2F2019-04-11%2F</url>
    <content type="text"><![CDATA[ResultMap 是 MyBatis 中最重要最强大的元素 可以实现复杂查询结果到复杂对象关联的关系转化 复杂 Java 对象到多张复杂数据表之间关联的转化 使用 ResultMap复杂对象关系：对象声明中的逻辑关系;主要包含三种： 关联 容器 嵌套 使用方式一，构造函数时传入(Constructor ) 类实例化时，将数据库检索结果用注入的方式在类实例化时通过类对象的构造函数注入到对象中。 idArg ： ID 参数，标记结果作为 ID 可以帮助提高整体效能(自增Id) arg ： 注入到构造方法的一个普通结果 一般在建立对象中有数据表关联的时候使用 实例数据库结构： 1.创建 Bean student 类12345678910111213141516171819202122232425262728public class Student &#123; private int id; private String userName; private String corp; private List&lt;Course&gt; courses; public Student(Integer id, String userName, String corp) &#123; this.id = id; this.userName = userName; this.corp = corp; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; ... 注意：要写构造函数 2. 添加接口函数12345package com.company;public interface studentOp &#123; public Student getStudent(int id);&#125; 3.在 mapper 中构建 ResultMap 映射方法123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;studentOp&quot;&gt; &lt;select id=&quot;getStudent&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentMap&quot;&gt; &lt;![CDATA[ select id,userName,corp from student where id = #&#123;id&#125; ]]&gt; &lt;/select&gt; &lt;resultMap id=&quot;StudentMap&quot; type=&quot;com.company.Student&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt; &lt;arg column=&quot;userName&quot; javaType=&quot;String&quot;/&gt; &lt;arg column=&quot;corp&quot; javaType=&quot;String&quot;/&gt; &lt;/constructor&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 4. 在测试类中调用1234567891011121314151617181920212223242526public class MoreMybatis &#123; public static void main(String[] args) &#123; // 1. 声明配置⽂文件的⺫⽬目录渎职 String resource = &quot;conf.xml&quot;; // 2. 加载应⽤用配置⽂文件 InputStream is = MoreMybatis.class.getClassLoader().getResourceAsStream(resource); // 3. 创建SqlSessonFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); // 4. 获取Session SqlSession session = sessionFactory.openSession(); try&#123; // 5. 获取操作类 StudentOp studentOp = session.getMapper(StudentOp.class); // 6. 完成查询操作 Student student = studentOp.getStudent(25); System.out.println(student.getId() + &quot; &quot; + student.getUserName()+ &quot; &quot;); System.out.println(student.getCourses().get(0).getCourseName() + &quot; &quot;); &#125;finally &#123; session.close(); &#125; &#125;&#125; 使用方式二，Collection 标签传入实现一对多的关联 id 一个id结果；标记结果作为ID 可以帮助提高整体效能 result 注入到字段或 JavaBean 属性的普通结果 当类对象中含有自定义的容器列表时。在 类 mapper 文件中使用 collection 标签注入。 在原 mapper 文件的基础上添加 collection 标签123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;StudentOp&quot;&gt; &lt;select id=&quot;getStudent&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentMapC&quot;&gt; &lt;![CDATA[ select s.id as user_id,userName,courseName,corp,c.id as courseId from student s left join UserCourse uc on s.id = uc.user_id left join course c on uc.course_id = c.id where s.id = #&#123;id&#125; ]]&gt; &lt;/select&gt; &lt;resultMap id=&quot;StudentMapC&quot; type=&quot;Student&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;user_id&quot; javaType=&quot;int&quot;/&gt; &lt;arg column=&quot;userName&quot; javaType=&quot;String&quot;/&gt; &lt;arg column=&quot;corp&quot; javaType=&quot;String&quot;/&gt; &lt;/constructor&gt; &lt;collection property=&quot;courses&quot; ofType=&quot;Course&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;courseId&quot;/&gt; &lt;result property=&quot;courseName&quot; column=&quot;courseName&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 使用方式三，Association 标签传入实现对象与对象之间的关联。 id 一个id 结果；标记结果作为 ID 可以帮助提高整体效能 result 注入到字段或JavaBean 属性的普通结果 当一个类对象中包含另一个类对象时使用 在 collection 标签下添加 association 标签所添加的对象需要在 collection 标签所引进的对象内有引用。 123456789101112131415161718192021222324252627&lt;mapper namespace=&quot;StudentOp&quot;&gt; &lt;select id=&quot;getStudent&quot; parameterType=&quot;int&quot; resultMap=&quot;StudentMapC&quot;&gt; &lt;![CDATA[ select s.id as user_id,userName,courseName,corp,c.id as courseId,t.id as teacher_id,teacherName from student s left join UserCourse uc on s.id = uc.user_id left join course c on uc.course_id = c.id left join teacher t on c.teacher_id = t.id where s.id = #&#123;id&#125; ]]&gt; &lt;/select&gt; &lt;resultMap id=&quot;StudentMapC&quot; type=&quot;Student&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;user_id&quot; javaType=&quot;int&quot;/&gt; &lt;arg column=&quot;userName&quot; javaType=&quot;String&quot;/&gt; &lt;arg column=&quot;corp&quot; javaType=&quot;String&quot;/&gt; &lt;/constructor&gt; &lt;collection property=&quot;courses&quot; ofType=&quot;Course&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;courseId&quot;/&gt; &lt;result property=&quot;courseName&quot; column=&quot;courseName&quot;/&gt; &lt;association property=&quot;teacher&quot; column=&quot;teacher_id&quot; javaType=&quot;Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;teacherId&quot;/&gt; &lt;result property=&quot;teacherName&quot; column=&quot;teacherName&quot;/&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; DataSource数据库连接池在 MyBatis 3.0 中内置了连接池；只需在 conf.xml 文件中配置数据库连接中dataSource设为 POOLED 就能启用连接池 1234567891011121314151617181920&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;jdbc&quot;/&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=&quot;StudentMapper.xml&quot;/&gt;--&gt; &lt;mapper resource=&quot;StudentMapperCollection.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 『项目地址』:https://github.com/wengfe/JAVA/tree/master/MoreMybatis/src]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>ResultMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis- SQL 映射文件解析]]></title>
    <url>%2F2019%2F04%2F06%2FJava%2FMybatis%2F2019-04-06%2F</url>
    <content type="text"><![CDATA[SQL 的文件映射在入门篇中，通过查询的例子，演示了如何使用 MyBatis。其中第一种方法是通过文件映射的方式，实现了对象操作和 SQL 语句之间的连接。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;GetUserInfo&quot;&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,name,password,sex,account from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 其实在映射文件中，应该添加 CDATA 标签。即： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;GetUserInfo&quot;&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; &lt;![CDATA[ select id,name,password,sex,account from user where id = #&#123;id&#125; ]]&gt; &lt;/select&gt;&lt;/mapper&gt; 为什么要使用&lt;![CDATA[ … ]]&gt;当使用的 SQL 语句比较复杂时，如: 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;GetUserInfo&quot;&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,name,password,sex,account from user where id = #&#123;id&#125; and account &lt; 10000 &lt;/select&gt;&lt;/mapper&gt; 会发现程序运行抛错： 12345Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession.### The error may exist in userMapper.xml### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 7; columnNumber: 85; 元素内容必须由格式正确的字符数据或标记组成。... xml 文件并不是专门为 MyBatis 服务的，它首先具有 xml 文件的语法。因此，”&lt; 10000”这段，会先被解析为xml的标签，因为 xml 的协议里没有该标签，所以报错。 使用&lt;![CDATA[ … ]]&gt;，可以保证如论如何&lt;![CDATA[ … ]]&gt;里面的内容都会被解析成SQL语句。因此，建议每一条SQL语句都使用&lt;![CDATA[ … ]]&gt;包含起来. SQL 增删改查select多条件查询一个结果1. 在映射文件中新增一条映射语句12345&lt;select id=&quot;getUserOne&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;![CDATA[ select id,name,password,sex,account from user where id = #&#123;id&#125; and name = #&#123;name&#125; ]]&gt; &lt;/select&gt; parameter只能是一个实体类，参数要和实体类里面定义的一致，如id、name，MyBatis 将会自动查找这些属性，然后将它们的值传递到预处理语句的参数中去。 使用参数的时候使用了”#”，另外还有一个符号”$”也可以引用参数，使用”#”最重要的作用就是防止SQL注入。 2. 在 Java 中使用映射语句12345678910111213public static User selectOne(int id, String name) &#123; SqlSession session = sqlSessionFactory.openSession(); User user = null; try &#123; user = session.selectOne(&quot;getUserOne&quot;, new User(id, name, null, 0, 0)); &#125; catch(Exception exception)&#123; System.out.println(exception); &#125; finally&#123; session.close(); &#125; return user; &#125; 3. 调用及结果：123public static void main(String[] args) &#123; System.out.println(selectOne(10,&quot;GuoYi&quot;)); &#125; 1User&#123;id=10, name=&apos;GuoYi&apos;, password=&apos;123456&apos;, sex=1, account=100&#125; 查询多个结果1. 在映射文件中新增一条映射语句123456&lt;select id=&quot;getUserList&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot; timeout=&quot;10000&quot; fetchSize=&quot;100&quot; statementType=&quot;PREPARED&quot; resultSetType=&quot;FORWARD_ONLY&quot;&gt; &lt;![CDATA[ select id,name,password,sex,account from user where id &gt; #&#123;id&#125; ]]&gt; &lt;/select&gt; 这条语句新增了很多参数，一一讲解： id—-和namespace确定唯一引用的SQL语句 parameterType—-参数类型，如果SQL语句中的动态参数只有一个，这个属性可有可无 resultType—-结果类型，注意如果返回结果是集合，应该是集合所包含的类型，而不是集合本身 flushCache—-将其设置为true，无论语句什么时候被调用，都会导致缓存被清空，默认值为false useCache—-将其设置为true，将会导致本条语句的结果被缓存，默认值为true timeout—-这个设置驱动程序等待数据库返回请求结果，并抛出异常事件的最大等待值，默认这个参数是不设置的（即由驱动自行处理） fetchSize—-这是设置驱动程序每次批量返回结果的行数，默认不设置（即由驱动自行处理） statementType—-STATEMENT、PREPARED或CALLABLE的一种，这会让 MyBatis 选择使用Statement、PreparedStatement或CallableStatement，默认值为PREPARED。这个相信大多数朋友自己写JDBC的时候也只用过PreparedStatement resultSetType—-FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE中的一种，默认不设置（即由驱动自行处理）2. 在 Java 中使用映射语句 123456789101112public static List&lt;User&gt; selectList(int id)&#123; SqlSession session = sqlSessionFactory.openSession(); List&lt;User&gt; users = null; try&#123; users = session.selectList(&quot;getUserList&quot;, id); &#125;catch (Exception e)&#123; System.out.println(e); &#125;finally &#123; session.close(); &#125; return users; &#125; 调用及结果类似多条件查询。 使用 resultMap 接收结果以上两个查询实例使用 resultType 接收查询条件，本例使用 resultMap 接收。 使用 resultType 是有前提的，需要假定列名和 Java Bean 中的属性名存在对应关系，如果名称不对应，需使用更繁琐的方式： 123456&lt;select id=&quot;getUserList&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot; timeout=&quot;10000&quot; fetchSize=&quot;100&quot; statementType=&quot;PREPARED&quot; resultSetType=&quot;FORWARD_ONLY&quot;&gt; &lt;![CDATA[ select user_id as &quot;id&quot;,user_name as &quot;name&quot;,password,sex,account from user where user_id &gt; #&#123;id&#125; ]]&gt; &lt;/select&gt; 为使用这个方式 我把数据库中的 id 和 name 列名改为 user_id user_name; 使用 resultMap 来接收结果： 12345678910111213&lt;resultMap id=&quot;UserResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;account&quot; column=&quot;account&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserList&quot; parameterType=&quot;int&quot; resultMap=&quot;UserResultMap&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot; timeout=&quot;10000&quot; fetchSize=&quot;100&quot; statementType=&quot;PREPARED&quot; resultSetType=&quot;FORWARD_ONLY&quot;&gt; &lt;![CDATA[ select * from user where user_id &gt; #&#123;id&#125; ]]&gt; &lt;/select&gt; 注意两点： 1、resultMap定义中主键要使用id 2、resultMap和resultType不可以同时使用 insert1. 在映射文件中添加 insert 语句12345&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;![CDATA[ insert into user values(null,#&#123;name&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;account&#125;) ]]&gt; &lt;/insert&gt; 2. 在 java 中调用123456789101112public static void insertUser()&#123; SqlSession session = sqlSessionFactory.openSession(); try&#123; session.insert(&quot;insertUser&quot;,new User(0,&quot;GuoWu&quot;,&quot;123456&quot;,0,10000)); session.commit(); &#125;catch (Exception e)&#123; e.printStackTrace(); session.rollback(); &#125;finally &#123; session.close(); &#125; &#125; insert 方法要传入的参数比较多的话，建议不要把每个属性单独作为形参，而是直接传入一个对象。 update 和 deleteupdate1. 映射文件添加 sql 语句12345&lt;update id=&quot;updateUserNameById&quot; parameterType=&quot;User&quot;&gt; &lt;![CDATA[ update user set name = #&#123;name&#125; where id = #&#123;id&#125;; ]]&gt; &lt;/update&gt; 2. Java 调用123456789101112public static void updateUser()&#123; SqlSession session = sqlSessionFactory.openSession(true); try&#123; session.update(&quot;updateUserNameById&quot;,new User(12,&quot;GuoGau&quot;,&quot;23456&quot;,1,800));// session.commit(); &#125;catch (Exception e)&#123; e.printStackTrace(); session.rollback(); &#125;finally &#123; session.close(); &#125; &#125; 3. 结果虽然更新时候的对象改了更多的字段，按照 sql 语句 只修改了 name 字段。 delete1. 映射文件添加 sql 语句123&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt; 2. Java 调用1234567891011public static void deleteUserById(int id)&#123; SqlSession session = sqlSessionFactory.openSession(true); try&#123; session.delete(&quot;deleteUserById&quot;,id); &#125;catch (Exception e)&#123; e.printStackTrace(); session.rollback(); &#125;finally &#123; session.close(); &#125;&#125; SQLSQL可以用来定义可重用的SQL代码段，可以包含在其他语句中，比如我把上面的插入换一下，先定义一个SQL： 123&lt;sql id=&quot;insertColumns&quot;&gt; name, password,sex, account&lt;/sql&gt; 在 insert 语句中复用： 1234&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into user(&lt;include refid=&quot;insertColumns&quot; /&gt;) values(null,#&#123;name&#125;, #&#123;password&#125;, #&#123;sex&#125;,#&#123;account&#125;);&lt;/insert&gt; 这里要把”&lt;![CDATA[ … ]]&gt;”给去掉，否则”&lt;”和”&gt;”就被当成SQL里面的小于和大于了，因此使用SQL的写法有一定限制，使用前要注意一下避免出错。 『项目地址』：https://github.com/wengfe/JAVA/tree/master/HelloMybatis/src 主要文件： sqlMapping.java userMapper.xml]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SQL 映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-SQLSessionFactory 配置文件解析]]></title>
    <url>%2F2019%2F04%2F05%2FJava%2FMybatis%2F2019-04-05%2F</url>
    <content type="text"><![CDATA[SQLSessionFactory 配置文件解析在入门文章里，配置了两个 xml 文件，本文来解析 SQLSessionFactory 的环境配置文件。在前文中命名未 conf.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;jdbc&quot;/&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;userMapper.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 下面来解析一下 里面的一些内容。 environmentsMyBatis可以配置多种环境，这会帮助你将 SQL 映射应用于多种数据库之中。例如测试和生产环境。或者你可能有多重生产级数据库却共享相同的模式，所以你会想到对不同数据库使用相同的SQL映射。 但是配置多种环境，只能为每个SqlSessionFactory实例选择一个。 我们之前在文中加载环境配置文件的方法是： 1SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); 其实该 build 有其他的重载方法。其中有配置环境参数的方法 123public SqlSessionFactory build(InputStream inputStream, String environment) &#123; return this.build((InputStream)inputStream, environment, (Properties)null); &#125; 即传入 environment ，指定的 environment 被绑定到 SqlSessionFactory ；如果不传入 environment ，default 指定的 environment 被绑定到 SqlSessionFactory。 1 transactionManager在MyBatis中有两种事物管理器类型，一种是JDBC，一种是MANAGED。 JDBC—-这个配置直接简单使用了JDBC的提交和回滚设置，它依赖于数据源得到的连接来管理事物范围 MANAGED—-这个配置几乎不做什么。它从来不提交或回滚一个连接，而它会让容器来管理事物的整个生命周期（比如Spring或J2EE应用服务器的上下文），默认情况下它会关闭连接，然而一些容器并不希望这样，因此如果你需要从连接中停止它，将closeConnection属性设置为false. 123&lt;transactionManager type=&quot;MANAGED&quot;&gt; &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;&lt;transactionManager type=&quot;MANAGED&quot;&gt; 2 dataSourcedataSource 元素使用基本的 JDBC 数据源接口来配置 JDBC 连接对象的资源。许多MyBatis的应用程序将会按照上面的示例来配置数据源，然而它并不是必须的，要知道为了方便使用延迟加载，数据源才是必须的。有三种内建的数据源类型（也就是type=”XXX”）： 2.1 UNPOOLED这个数据源的实现是每次被请求时打开和关闭连接。它有一点慢，这是对简单应用程序的一个很好的选择，因为它不需要及时的可用连接，不同的数据库对这个的表现也是不一样的，所以对某些数据库来说配置数据源并不重要，这个配置也是闲置的。UNPOOLED 类型的数据源仅仅用来配置以下六种属性： driver—-这是JDBC驱动的Java类的完全限定名 url—-这是数据库的JDBC URL地址 username—-登陆数据库的用户名 password—-登录数据库的密码 defaultTransactionIsolationLevel—-默认的连接事物隔离级别 driver.encoding—-传递数据库驱动的属性，前缀以”driver.”开头即可，”driver.encoding”表示的就是传递 encoding 属性 2.2 POOLED这是 JDBC 连接对象的数据源连接池的实现，用来避免创建新的连接实例时必要的连接和认证时间。这是一种当前 Web 应用程序用来快速响应请求的很流行的方法。除了上述（UNPOOLED）的属性之外，还有些别的属性可以用来配置 POOLED 数据源： poolMaximumActiveConnections—-在任意时间存在的活动（也就是正在使用）连接的数量，默认值为10 poolMaximumIdleConnections—-任意时间存在的空闲连接数 poolMaximumCheckoutTime—-在被强制返回之前，池中连接被检查的时间，默认值为2000毫秒也就是20秒 poolTimeToWait、poolPingQuery、poolPingEnabled、poolPingConnectionsNotUsedFor—-这些都是一些侦测数据库连接的属性 2.3 JNDI这个数据源的实现是为了使用如 Spring 或应用服务器这类的容器，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这个数据源只需要两个属性： initial_context—-从初始上下文寻找环境，这个是可选属性，如果被忽略，那么 data_source 属性将会直接以 initialContext 为背景再次寻找 data_source—-这是引用数据源实例位置的上下文路径，它会以由 initial_context 查询返回的环境为背景来查找，如果 initial_context 没有返回结果时，直接以初始上下文为环境来查找 和其它数据源配置相似，它也可以通过名为”env.”的前缀直接向初始上下文发送属性。 3 mappersMyBatis 的行为已经由上述元素配置好，下面是告诉 MyBatis 到哪里找到 SQL 的映射文件。可以通过使用相对路径的资源引用，或者字符表示，或者url引用的完全限定名。 123456789101112// 使用相对于类路径的资源&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;// 使用完全限定路径&lt;mappers&gt; &lt;mapper url=&quot;file:///var/sqlmaps/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/sqlmaps/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/sqlmaps/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 4 settings下面多讲一个属性，这个属性可以不在config.xml中出现，但是比较重要 settings，是非常重要的参数，它们会改变MyBatis在运行时的行为方式。这面这个表格描述了设置信息，它们的含义和默认值： 参数设置 描述 有效值 默认值 cachedEnabled 用于配置使全局的映射器启用或禁止缓存 true false true lazyLoadingEnabled 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 true false true aggressiveLazyLoading 当启用时，有延迟加载属性的对象在被调用时将会完全加载任任意属性，否则每种属性将会按需要加载 true false true multipleResultSetsEnabled 允许或不允许多种结果集从一个单独的语句中返回（需要合适的驱动） true false true useColumnLabel 使用列标签代替列名。不同的驱动在这方面表现不同，参考驱动文档或充分测试两种方法来决定所使用的驱动 true false true useGeneratedKeys 允许JDBC支持生成的键，需要合适的驱动。如果设置为true则这个驱动强制生成的键被使用，尽管一些驱动拒绝兼容但仍然有效。 true false true autoMappingBehavior 指定MyBatis如何自动映射列到字段/属性PARTIAL只会自动映射简单、没有嵌套的结果。FULL会自动映射任意复杂的结果。 NONE PARTIAL FULL PARTIAL defaultExecutorType 配置默认的执行器。SIMPLE执行器没有什么特别之处，REUSE执行器重用预处理语句，BATCH执行器重用语句和批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待一个数据库响应的时间。 任何正整数 Not Set(null) 完整的设置信息元素的示例配置如下： 12345678910&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;enhancementEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25000&quot;/&gt;&lt;/settings&gt; 主要的配置信息就是上面这些，前三个比较重要，settings 属于高级设置.]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>conf.xml</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 入门]]></title>
    <url>%2F2019%2F04%2F03%2FJava%2FMybatis%2F2019-04-03%2F</url>
    <content type="text"><![CDATA[MyBatis前身是 apach 基金会下的一个开源项目 iBatis 支持自定义 SQL 、存储过程和高级映射的持久化框架 使用 XML 或者注解配置 能够映射基本数据元素、接口、Java对象到数据库 MyBatis是一款支持普通SQL查询、存储过程和高级映射的持久层框架。MyBatis消除了几乎所有的JDBC代码、参数的设置和结果集的检索。MyBatis可以使用简单的XML或注解用于参数配置和原始映射，将接口和Java POJO（普通Java对象）映射成数据库中的记录。 映射方式 数据库的每一行映射为每一个对象 每一列映射为对象的每一个属性 工作流程机制 根据 XML 或者注解加载 SQL 语句、参数映射、结果映射到内存 应用程序调用 API 传入参数和 SQL ID. MyBatis 自动生成 SQL 语句完成数据库访问，转换执行结果返回应用程序 以查询操作来对整个过程进行描述 配置jar 加载 mybatis-3.2.3 mysql-connector-java SQLSessionFactory每个 MyBatis 应用都基于 SqlSessionFactory 实例为中心。通过该实例，MyBatis 可以获取对对象的操作转换为对数据库数据进行操作的 sql 的 session。 SqlSessionFactory 的全局配置⽂文件，⽂文件名为conf.XML。 该⽂文件需要放在根目录下，即src/main/java目录下 该文件包含了对 MyBatis 的核心配置。 transactionManage 对后端连接数据库实例的数据源，决定数据范围和数据管理方式的事务管理器 dataSource 后端数据库源：driver、url、username、password conf.xml 配置示例123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;jdbc&quot;/&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; Java 对象构建(Bean类)构造对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class User &#123; private int id; private String name; private String password; private int sex; private int account; public User(int id, String name, String password, int sex, int account) &#123; this.id = id; this.name = name; this.password = password; this.sex = sex; this.account = account; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public String getPasswors() &#123; return password; &#125; public int getSex() &#123; return sex; &#125; public int getAccount() &#123; return account; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPasswors(String password) &#123; this.password = password; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public void setAccount(int account) &#123; this.account = account; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &quot;, sex=&quot; + sex + &quot;, account=&quot; + account + &apos;&#125;&apos;; &#125;&#125; 构建接口123456public interface GetUserInfo &#123; public User getUser(int id); public void addUser(User user); public void updateUser(User user); public void deleteUser(User user);&#125; 构建 Java 对象和 SQL 语句映射关系配置文件在 src 目录下新建 userMapper.xml 文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;GetUserInfo&quot;&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,name,password,sex,account from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在 conf.xml 文件中注册 mapperSqlSessionFactory中添加mapper映射。 123456... &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;userMapper.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 数据查询操作工作流程 加载配置文件 应用配置文件 关联映射文件 sqlSession 生成 SQLSessionFactory 获取 SQLSession 执行查询 Session 执行SQL 测试程序1234567891011121314151617181920212223public class HelloMyBatis &#123; public static void main(String[] args) &#123;// 1.声明配置文件的目录读值 String resource = &quot;conf.xml&quot;;// 2. 加载应⽤用配置⽂文件 InputStream is = HelloMyBatis.class.getClassLoader() .getResourceAsStream(resource);// 3. 创建SqlSessonFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);// 4. 获取Session SqlSession session = sessionFactory.openSession(); try &#123;// 5. 获取操作类 GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class);// 6. 完成查询操作 User user = getUserInfo.getUser(2); System.out.println(user.getId() + &quot; &quot; + user.getName() + &quot; &quot; + user.getAccount()); &#125; finally &#123;// 7.关闭Session session.close(); &#125; &#125;&#125; 映射通过注解的方式声明不需要添加 接口类的 Mapper.xml 文件，也不用在 SQLSessionFactory 中声明 mapper.xml 。 1. 在接口类的方法上添加 sql 注解123456789import org.apache.ibatis.annotations.Select;public interface GetUserInfoAnnotation &#123; @Select(&quot;select id,name,password,sex,account from user where id = #&#123;id&#125;&quot;) public User getUser(int id); public void addUser(User user); public void updateUser(User user); public void deleteUser(User user);&#125; 2. 在主程序中添加映射关系到接口对象12345 3. 创建SqlSessionFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);// 3.1 添加映射关系到类对象 注解方式 Configuration conf = sessionFactory.getConfiguration(); conf.addMapper(GetUserInfoAnnotation.class); 其他步骤与文件映射方法一致。 其他 SQL 操作（增删改）###文件映射方式在 Mapper 文件中添加 sql 的文件。 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http:// mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;GetUserInfo&quot;&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,name,password,sex,account from user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into user (name,password,sex,account) values(#&#123;name&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;account&#125;) &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update user set account = #&#123;account&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;User&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 运行 MyBatis1234567891011121314151617181920212223242526272829303132333435363738394041import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;public class moreMybatis &#123; public static void main(String[] args) &#123;// 1. 声明配置⽂文件 String resource = &quot;conf.xml&quot;;// 2. 加载应⽤用配置⽂文件 InputStream is = moreMybatis.class.getClassLoader().getResourceAsStream(resource);// 3. 创建SqlSessonFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);// 关闭sql事务模式 SqlSession session = sessionFactory.openSession(true); try&#123;// 5. 获取操作类 GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class);// 插⼊入⽤用户 User user = new User(7,&quot;xiaoBai&quot;,&quot;123456&quot;,0,10000); getUserInfo.addUser(user); System.out.println(user.getId());// 查询⽤用户 user = getUserInfo.getUser(user.getId()); System.out.println(user);// 更新用户账户信息 user.setAccount(800); getUserInfo.updateUserAccount(user);// 删除⽤用户 getUserInfo.deleteUser(user.getId()); &#125;finally &#123; session.close(); &#125; &#125;&#125; MyBatis 的优劣 优势： 入门门槛较低 更加灵活，SQL 优化 劣势 需要自己编写 SQL ，工作量大 数据库移植性差 『项目地址』:https://github.com/wengfe/JAVA/tree/master/HelloMybatis/src]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>数据库框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁的分析与解决]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F2019-04-02%2F</url>
    <content type="text"><![CDATA[死锁指两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。 死锁产生的必要条件互斥 并发执行的事务为了进行必要的隔离保证执行正确，在事务结束前，需要对修改的数据库记录持锁，保证多个事务对相同数据库记录串行修改。 串行修改：a 事务尚未提交，b 事务不能修改同个数据记录 对于大型并发系统无法避免 请求与保持 已经持有一个锁资源，等待另外一个锁资源 死锁仅发生在请求两个或两个以上的锁对象 由于应用需要，难以消除 不剥夺 已经获得锁资源的事务，在未执行前，不能被强制剥夺，只能使用完时，由事务自己释放。 一般用于已经出现死锁时，通过破坏该条件达到解除死锁的目的。 数据库系统通常通过一定的死锁检测机制发现死锁，强制回滚代价相对较小的事务，达到解除死锁的目的。 环路等待 发生死锁时，必然存在一个事务—锁的环形链 按照同一顺序获取锁，可以破坏该条件 通过分析死锁事务之间的锁竞争关系，调整 SQL 的顺序，达到消除死锁的目的。 MySQL 中的锁排他锁与其他任何锁都是冲突的。 共享锁多个事务可以共享一把锁。 加锁方式外部加锁由应用程序执行特定语句，显式的加锁； 可以通过分析 sql 语句，比较容易看清锁的依赖关系 共享锁 select * from table lock in share mode 排他锁 select * from table for update 内部加锁为了实现 ACID 特性，由数据库内部自动添加 加锁规则繁琐，与 SQL 执行计划、事务隔离级别、表索引结果有关，不容易排查死锁情况 哪些 SQL 需要持有锁 快照读 所有 select 语句都属于快照读 Innodb 实现了多版本控制（MVCC），支持不加锁的快照度 「保证 select 语句的性能」 能够保证同一个 select 结果集一致 不能保证同一个事务内部，select 语句和其他语句的数据一致性，如有业务需要，需外部显式加锁 当前读 select * from table lock in share mode select * from table for update Update from table set … Insert into … Delete from table … 显式加锁的读，以及更新插入删除操作语句，都是可触发 MySQL 内部加锁的 捕获死锁的 sql 语句sql 语句： 1show engine innodb status]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务原理]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FJDBC%2F2019-04-01%2F</url>
    <content type="text"><![CDATA[事务事务是并发控制的基本单位，指作为单个逻辑工作单元执行的一系列操作，而这些逻辑工作需要满足 ACID 特性。 ACID 原子性（Atomicity）:事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。 一致性（Consistency）：事务执行的结果必须是使数据库数据从一个一致性状态变到另外一种一致性状态。 隔离性（Isolation）：一个事务的执行过程中不能影响到其他事务的执行，事务内部的操作及使用的数据对其他事务是隔离的，并发执行各个事务之间无不干扰。 持续性（Durability）：即一个事务执一旦提交，它对数据库数据的改变是永久性的。之后的其它操作不应该对其执行结果有任何影响。 JDBC 的事务控制Connection 对象下的三个方法实现对事务的控制。 setAutoCommit() 设置为 false，将所属 Connection 对象的后续语句作为 JDBC 事务进行处理，直到调用 commit() 方法。 true 将所属对象的后续每个语句作为单独的 sql 语句进行处理（默认状态）。 commit()提交事务，使事务中的所有 sql 生效。 rollback()回滚事务- 回滚到事务开始之前的状态 1234567891011121314conn = ds.getConnection();// 开启事务 conn.setAutoCommit(false); psta = conn.prepareStatement(&quot;update user set account = ? where name = ?&quot;); psta.setInt(1, 0); psta.setString(2, &quot;Mike&quot;); psta.execute(); psta.setString(1, &quot;100&quot;); psta.setString(2, &quot;Bob&quot;); psta.execute();// 提交事务 conn.commit(); 在事务未提交之前，所有的 sql 语句都不会执行。 设置检查点setSavePoint()设置数据库保存点，在出现异常后，可以回复到该点的状态 rollback(SavePoint savePoint)回复方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void Transaction() &#123; Connection conn = null; PreparedStatement psta = null; ResultSet rs = null; Savepoint sp = null; try &#123; conn = ds.getConnection();// 开启事务 conn.setAutoCommit(false); psta = conn.prepareStatement(&quot;update user set account = ? where name = ?&quot;); psta.setInt(1, 0); psta.setString(2, &quot;Mike&quot;); psta.execute(); sp = conn.setSavepoint(); psta.setString(1, &quot;100&quot;); psta.setString(2, &quot;Bob&quot;); psta.execute();// 提交事务// conn.commit(); throw new SQLException(); &#125; catch (SQLException e) &#123; try &#123;// 回滚事务到检查点 conn.rollback(sp); psta.setString(1, &quot;100&quot;); psta.setString(2, &quot;GuoSi&quot;); psta.execute(); conn.commit(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125;// e.printStackTrace(); &#125; finally &#123; try &#123; if (conn != null) conn.close(); if (psta != null) psta.close(); if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 设置 JDBC 中的隔离级别getTranactionIlsoLation()setTranactionIlsoLation() 各个隔离级别内容在 MySQL 45讲 第三讲内容中 『项目地址』：https://github.com/wengfe/JAVA/blob/master/HelloJDBC/src/HelloTransaction.java]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入与防范]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F2019-03-31%2F</url>
    <content type="text"><![CDATA[SQL注入通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 SQL 注入实例：登录请求 情境 登录名 密码 正常 zhangsan 123456 SQL 注入 zhangsan’;– 123 正常查询语句为： 1select * from user where userName = &apos;zhangsan&apos; and passwoad = &apos;123456&apos; 注入后： 1select * from user where userName = &apos;zhangsan&apos;;-- &apos; and passwoad = &apos;123456&apos; 因为后面添加的单引号和分号断开了查询的后续条件，并通过 “– “ 进行了注释，使原sql 语句语义发生了改变。 解决办法通过 connect 下的 preparedStatement 方法来预编译 sql，后续加入参数；因为 sql 语句进行了预编译，保障了参数传入后，整条语句的语义不会发生变化，从而防范了 SQL 注入的问题。 『项目地址』: https://github.com/wengfe/JAVA/tree/master/HelloJDBC/src]]></content>
      <categories>
        <category>Java</category>
        <category>SQL注入与防范</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>preparedSatement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FJDBC%2F2019-03-26%2F</url>
    <content type="text"><![CDATA[因为每次创建一个数据库链接都是一次极大的资源消费，所以连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，可以使一个数据库连接可以得到高效、安全的复用，能避免了数据库连接频繁建立、关闭的开销。 连接池的本质：介于 Java 应用 和 JDBC 之间的 Java 架包. 使用 数据库连接池，需要先引入 3 个架包： commons-logging commons-dbcp2 commons-pool2前两个架包可以直接在 apache 找到， pool2 架包在 码农文库中找到； 调用 connection.close() 方法，在连接池中被重写，在连接池中调用 close 方法，是释放归还数据库连接，供其他线程调用，并不是销毁连接。 流程1.导入 3 个架包2.初始化连接池3.通过连接池连接数据库（类似JDBC）4.拿到结果5.清理环境 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.commons.dbcp2.BasicDataSource;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class HelloDBCP &#123; public static BasicDataSource ds = null; public static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;; public static final String JDBC_URL = &quot;jdbc:mysql://localhost/test?useSSL=true&quot;; public static final String USER = &quot;root&quot;; public static final String PASSWORD = &quot;admin&quot;;// 初始化 连接池 public static void dbpoolInit() &#123; ds = new BasicDataSource(); ds.setDriverClassName(JDBC_DRIVER); ds.setUrl(JDBC_URL); ds.setUsername(USER); ds.setPassword(PASSWORD); &#125; public void dsPoolTest() &#123; Connection conn = null; Statement stat = null; ResultSet rs = null; try &#123; conn = ds.getConnection(); stat = conn.createStatement(); rs = stat.executeQuery(&quot;select * from user&quot;); while (rs.next()) &#123; System.out.println(rs.getString(&quot;name&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (conn != null) conn.close(); if (stat != null) stat.close(); if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; dbpoolInit(); new HelloDBCP().dsPoolTest(); &#125;&#125; 连接池参数配置BAsicDataSource.setInitialSize() 在连接池启用的时候预制一定数量的数据库连接.setMaxTotal() 连接池最大线程连接数.setMaxWaitMillis() 线程最大等待时间.setMaxIdle() 空闲连接数超过该设置，连接池销毁数据库连接.setMinIdle() 空闲连接数低于该设置，连接池创建数据库连接.setTestWhileIdle(True) 检查空闲数据库连接是否已与数据库断开连接，断开后销毁连接.setMinEvictableIdleTimeMillis() 销毁连接的最小连接时间，当连接时间超过该设置，被自动销毁.setTimeBetweenEvicationRunsMillis() 检查运行时间的间隔 『项目地址』:https://github.com/wengfe/JAVA/blob/master/HelloJDBC/src/HelloDBCP.java]]></content>
      <categories>
        <category>Java</category>
        <category>DBCP</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>preparedSatement</tag>
        <tag>DBCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 进阶]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FJDBC%2F2019-03-22-1%2F</url>
    <content type="text"><![CDATA[游标操作方式-分批查询游标提供一种客户端读取部分服务器端结果集的机制。当 sql 语句的匹配条件太弱时，sql 结果会返回大量的数据，就有可能导出出现内存溢出。所以就出现了将结果分批处理的方式； 流程：1.在配置 JDBC URL 时，在最后加上参数： useCursorFetch=true 开启游标属性 1static String DB_URL = &quot;jdbc:mysql://localhost:3306/test?useCursorFetch=true&quot; 2.创建 preparedSatement 对象，在使用 prepareStatement 方法创建对象时，预编译 sql 语句。 conn.prepareStatement(sql,游标类型,能否更新记录);游标类型：ResultSet.TYPE_FORWORD_ONLY:只进游标ResultSet.TYPE_SCROLL_INSENSITIVE:可滚动。但是不受其他用户对数据库更改的影响。ResultSet.TYPE_SCROLL_SENSITIVE:可滚动。当其他用户更改数据库时这个记录也会改变。能否更新记录：ResultSet.CONCUR_READ_ONLY,只读ResultSet.CONCUR_UPDATABLE,可更新 3.使用 setFetchSize 方法，设置分批处理的结果数 4.通过 setString 方法传入条件参数，第一个参数表示 参数位置，第二个参数为条件值 preparedSatement 可以写动态参数化查询preparedSatement 可以预编译 sql 语句preparedSatement 可以防止SQL注入式攻击 代码实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.sql.*;public class Main &#123; static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;; static String DB_URL = &quot;jdbc:mysql://localhost:3306/test?useSSL=true&quot;; static final String USER = &quot;root&quot;; static final String PASSWORD = &quot;admin&quot;; public static void main(String[] args) throws ClassNotFoundException&#123; Connection conn = null; Statement statement = null; PreparedStatement preparedStatement = null; ResultSet rs = null;// 1. 装载数据库驱动程序； Class.forName(JDBC_DRIVER);// 2. 通过JDBC建立数据库连接； try &#123; //在 url 中 开启 游标属性 DB_URL = DB_URL + &quot;&amp;useCursorFetch=true&quot;; conn = DriverManager.getConnection(DB_URL,USER,PASSWORD);// 3.访问数据库，执行SQL语句；// statement = conn.createStatement();// rs = statement.executeQuery(&quot;select name from test.user &quot;);// 对 preparedStatement 的 sql 语句进行预编译, ？ 表示参数 preparedStatement = conn.prepareStatement(&quot;select * from test.ipdata where id=? and startip = ?&quot;);// 通过 preparedStatement 使用游标 进行分批查询语句 preparedStatement.setFetchSize(1);// 通过setInt 或者 setString 将，预编译的 sql 语句中的 条件参数传递进去 preparedStatement.setInt(1,13); preparedStatement.setString(2,&quot;16844800&quot;); rs = preparedStatement.executeQuery();// 4.获得执行结果 while(rs.next()) &#123; System.out.println(&quot;Hello &quot; + rs.getString(&quot;country&quot;)); &#125; &#125; catch (SQLException e) &#123;// 异常处理 e.printStackTrace(); &#125; finally &#123; // 5. 断开数据库连接，清理环境 try &#123; if(conn != null) &#123; conn.close(); &#125; if(statement != null) &#123; statement.close(); &#125; if(rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; // pass &#125; &#125; &#125;&#125; 大对象读取-流方式当读取大对象时，有可能出现对象内容太大，内存放不下，从而出现的内存溢出问题。 主要涉及方法 ResultSet.getBinaryStream() 方法。 流程 通过对 ResultSet 对象使用 getBinaryStream() 获取流对象。 每次读取流对象中的一行内容输出到外部文件中 重复2 步骤，直至读取完流对象内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) throws ClassNotFoundException &#123; Connection conn = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; Class.forName(JDBC_DRIVER); try &#123; conn = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);// 创建 preparedStatement 对象 preparedStatement = conn.prepareStatement(&quot;select * from blog where id = ?&quot;); preparedStatement.setInt(1, 1);// 执行 sql resultSet = preparedStatement.executeQuery(); while (resultSet.next()) &#123;// 获取对象流 InputStream in = resultSet.getBinaryStream(&quot;context&quot;);// 将对象流写入文件 File f = new File(FILE_URL); OutputStream out = new FileOutputStream(f); int temp = 0; while ((temp = in.read()) != -1) &#123;//边读边写 out.write(temp); &#125; in.close(); out.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (conn != null) conn.close(); if (preparedStatement != null) preparedStatement.close(); if (resultSet != null) resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 一条语句多条执行- sql 的批处理流程： statement 对象使用 addBatch() 方法添加 sql 语句 statement 对象使用 executeBatch() 方法执行所有添加的 sql 语句 statement 对象使用 clearBatch() 方法清空已执行的 sql 语句 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class HelloBatch &#123; static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;; static String DB_URL = &quot;jdbc:mysql://localhost:3306/test?useSSL=true&quot;; static final String USER = &quot;root&quot;; static final String PASSWORD = &quot;admin&quot;; static void insertUsers(Set&lt;String&gt; users) throws ClassNotFoundException&#123; Connection conn = null; Statement statement = null; ResultSet rs = null;// 1. 装载数据库驱动程序； Class.forName(JDBC_DRIVER);// 2. 通过JDBC建立数据库连接； try &#123; conn = DriverManager.getConnection(DB_URL,USER,PASSWORD);// 3.访问数据库，执行SQL语句； statement = conn.createStatement();// 添加 sql 语句到 Batch for (String user : users) &#123; statement.addBatch(&quot;insert into user(name) values (&apos;&quot; + user + &quot;&apos;)&quot;); System.out.println(&quot;insert into user(name) values (&quot; + user + &quot;)&quot;); &#125;// 批执行 sql 语句 statement.executeBatch();// 清空已执行语句 statement.clearBatch(); &#125; catch (SQLException e) &#123;// 异常处理 e.printStackTrace(); &#125; finally &#123; // 5. 断开数据库连接，清理环境 try &#123; if(conn != null) &#123; conn.close(); &#125; if(statement != null) &#123; statement.close(); &#125; if(rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; // pass &#125; &#125; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; Set&lt;String&gt; users = new HashSet&lt;&gt;(); users.add(&quot;GuoYi&quot;); users.add(&quot;GuoEi&quot;); users.add(&quot;GuoSi&quot;); insertUsers(users); &#125;&#125; jdbc 设置字符集在 JDBC URL 中添加参数 characterEncoding=utf8 数据库设置字符集]]></content>
      <categories>
        <category>Java</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>preparedSatement</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 基础（下）]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FJDBC%2F2019-03-22%2F</url>
    <content type="text"><![CDATA[Java 应用程序访问数据库本文通过代码 JDBC 访问数据库，并解决两个在使用 JDBC 新手常见的问题；前置：本机安装 Mysql 服务，且已在本地创建了 test 库 user 表 intellij 创建 HelloJDBC 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.sql.*;public class Main &#123; static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;; static final String DB_URL = &quot;jdbc:mysql://localhost:3306/test?useSSL=true&quot;; static final String USER = &quot;root&quot;; static final String PASSWORD = &quot;admin&quot;; public static void main(String[] args) throws ClassNotFoundException&#123; Connection conn = null; Statement statemente = null; ResultSet rs = null;// 1. 装载数据库驱动程序； Class.forName(JDBC_DRIVER);// 2. 通过JDBC建立数据库连接； try &#123; conn = DriverManager.getConnection(DB_URL,USER,PASSWORD);// 3.访问数据库，执行SQL语句； statemente = conn.createStatement(); rs = statemente.executeQuery(&quot;select name from test.user &quot;);// 4.获得执行结果 while(rs.next()) &#123; System.out.println(&quot;Hello &quot; + rs.getString(&quot;name&quot;)); &#125; &#125; catch (SQLException e) &#123;// 异常处理 e.printStackTrace(); &#125; finally &#123; // 5. 断开数据库连接，清理环境 try &#123; if(conn != null) &#123; conn.close(); &#125; if(statemente != null) &#123; statemente.close(); &#125; if(rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; // pass &#125; &#125; &#125;&#125; 运行报错：in thread “main” java.lang.ClassNotFoundException: com.mysql.jdbc.Driver项目未安装 mysql-connector-java 依赖；我下载的是 mysql-connector-java-5.1.47.tar.gz 在 file -&gt; project structure -&gt; Libraries -&gt; 点击 + 号 选择 java -&gt; 选择刚刚下载的 mysql-connector-java 包。 Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established…MySQL在高版本需要指明是否进行SSL连接。需要在 JDBC URL 中增加参数：ssl=true或者false 1url = jdbc:mysql://127.0.0.1:3306/framework?characterEncoding=utf8&amp;useSSL=true 『项目地址』:https://github.com/wengfe/JAVA/tree/master/HelloJDBC/src]]></content>
      <categories>
        <category>Java</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 基础（上）]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FJDBC%2F2019-03-21%2F</url>
    <content type="text"><![CDATA[本文针对 JDBC 的流程介绍，以及 JDBC API 和 statement API 和 ResultSet API 的解释。 JDBC URL 的创建JDBC URL：后端数据库的唯一标识符。jdbc:子协议，并且载入服务器的主机名、端口、数据库名(或引用)。 1jdbc:mysql://10.164.172.20:3306/cloud_study jdbc 协议，固定不变的 mysql 子协议，DriverManager 确定数据库驱动 10.164.172.20:3306/cloud_study 子名称部分 10.164.172.20 主机 3306 数据库端口号 cloud_study 数据库 database 常用的三种 jdbc url 创建12345jdbc:mysql://&lt;ip&gt;:&lt;port&gt;/databasejdbc:oracle:thin:@&lt;ip&gt;:&lt;port&gt;:databasejdbc:microsoft:sqlserver://&lt;ip&gt;:&lt;port&gt;;DatabaseName=database JDBC API JDBC Driver 通过 Class.forName 向 DriverManager 加载数据库驱动； DriverManager 的 getConnection 方法建立一条到后端数据库的物理连接； Connection 对象创建通过 createStatement 方法创建一个或者多个 Statement 对象； statement 对象执行 sql 语句，返回 ResultSet 对象或者 int 对象； Statement 对象相当于 sql 容器；可以承载 sql 语句；并通过 executeQuery 执行查询语句，返回一个 ResultSet 对象。execute 执行删语句，executeUpdate 执行更新语句 返回一个 int 对象； statement API1234567891. execute(String sql):执行SQL 删语句，如果返回值是结果集则为true,否则为false2. executeQuery(String sql):执行SQL 查询语句，返回值为ResultSet3. executeUpdate(String sql):执行SQL 更新语句，返回值为所影响的行数 4. addBatch(String sql):向当前Statement对象的命令列表中添加新的批处理SQL语句5. clearBatch():清空当前Statement对象的命令列表6. executeBatch()：执行当前Statement对象的批处理语句，返回值为每个语句所影响的函数数组7. getConnection():返回创建了该Statement对象的Connection对象8. getQueryTimeout():获取等待处理结果的时间9. setQueryTimeout():设置等待处理结果的时间 ResultSet APIResultSet 对象代表了 sql 查询的一个结果，所以 ResultSet 对象的内容其实是一张二元表。 1234567891011121314151617181920211. first()/beforeFirst():将游标移动到ResultSet中第一条记录(的前面，通过 next() 方法返回第一条记录位置)2. last()/afterLast():将游标移动到ResultSet中最后一条记录(的后面，通过 previous() 方法返回第一条记录位置)3. absolute(int column):将游标移动到相对于第一行的指定行，负数则为相对于最后一条记录4. relative(int rows):将游标移动到相对于当前行的第几行,正为向下，负为向上5. next():将游标下移一行6. previous():将游标上移一行7. insertRow():向当前ResultSet和数据库中被插入行处插入一条记录8. deleteRow():将当前ResultSet中的当前行和数据库中对应的记录删除9. updateRow():用当前ResultSet中已更新的记录更新数据库中对应的记录10. cancelUpdate():取消当前对ResultSet和数据库中所做的操作11. findColumn(String columnName):返回当前ResultSet中与指定列名对应的索引12. getRow():返回ResultSet中的当前行号13. refreshRow():更新当前ResultSet中的所有记录14. getMetaData():返回描述ResultSet的ResultSetMetaData对象15. isAfterLast(): 是否到了结尾16. isBeforeFirst(): 是否到了开头17. isFirst():是否第一条记录 18. isLast(): 是否最后一条记录19. wasNull():检查列值是否为NULL值，如果列的类型为基本类型，且数据库中的值为0，那么这项检查就很重要。由于数据库NULL也返回0，所以0值和数据库的NULL不能区分。如果列的类型为对象，可以简单地将返回值与null比较20. close():关闭当前ResultSet]]></content>
      <categories>
        <category>Java</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 浅入]]></title>
    <url>%2F2019%2F03%2F20%2FJava%2FServlet%2F2019-03-20-1%2F</url>
    <content type="text"><![CDATA[JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。 简化的 Servlet JSP = HTML + JAVA + JSP tag JSP vs Servlet 侧重点 JSP 侧重试图 Servlet 侧重逻辑控制 内置对象 JSP 有内置对象供选择 Servlet 没有 本质JSP 是对 Servlet 的简化。使用 JSP 只需要开发完成需要输出到客户端的内容；JSP 中的 Java 脚本如何内嵌到类中是由 JSP 容器完成的；Servlet 是一个完整的 Java 类。 JSP 处理流程 Tomcat 既是一个 Servlet 容器，也是一个 JSP 容器。 客户端发送 JSP 请求到 JSP 容器 -&gt; 请求对应的 JSP 文件 -&gt; JSP容器载入对应的 JSP 文件，并转为对应的 Servlet 文件 -&gt; JSP 容器将 Servlet 文件编译为可执行的类(.class) -&gt; 将原始请求传递给 Servlet 容器 -&gt; web 服务器组件调用 Servlet 容器，载入 Servlet 实例 -&gt; Servlet 容器产出 html 页面输出到 HttpResponse 中交给 web 服务器 -&gt; web 服务器以静态页面的形式将 response 返回给客户端 JSP 基本语法JSP 语法主要包含JSP元素和模板数据两类。 模板数据JSP 引擎不处理的地方，如 html 页面。主要为：静态内容 JSP 元素主要为： 指令、注释、表达式、声明、脚本 JSP 声明参数变量声明 一个声明语句可声明一个或多个变量、方法，供后面的 Java 代码使用 书写格式： 1&lt;%! declaration;[declaration;]+ ... %&gt; 实例： 1&lt;%! int a, b, c; %&gt; JSP 表达式包含了脚本语言的表达式，先转换为 String，然后被插入在表达式出现的地方；所以可以在文本行中使用表达式，不用管是否是 html 标签 表达式元素中可以包含任何符合 Java 语言规范的表达式，但是不能使用分号来结束表达式 书写格式： 1&lt;%= 表达式 %&gt; 实例： 1&lt;p&gt; Today&apos;s date: &lt;%= ( new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt; 嵌入到 html 标签的表达式 JSP 脚本 可以是任意量的 Java 语句、变量、方法或表达式 书写格式： 1&lt;% 代码片段 %&gt; 实例： 1&lt;%= out.println(&quot;your ip address is&quot; + request.getRemoteAddr());%&gt; JSP 注释 主要为代码作注释以及将某段代码注释 书写格式： 1&lt;%-- 注释内容 --%&gt; JSP 指令设置 JSP 页面相关属性，不会有可见的相关输出 page 指令 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 import、 errorPage 指令 include 指令 向当前页面插入一个静态的文件内容 taglib 指令 引入自定义标签库，并可指定前缀JSP 内置对象JSP 对每个页面提供的 Java 对象;开发者可以直接使用，而不用先进行显式声明。亦称为预定义变量; 对象 描述 request HttpServletRequest 类的实例 response HttpServletResponse 类的实例 out printWriter 类的实例，用于把结果输出至网页 session HttpSession 类的实例 application ServletContext 类的实例，与应用上下文有关 Config ServletConfig 类的实例 page 类似于 Java 类中的 this 关键字 pageContext PageContext 类的实例，提供对 JSP 页面所有对象以及命名空间的访问 Exception Exception 类的对象，代表发生错误的 JSP 页面中对用的异常对象 创建一个 JSP 项目1.创建 maven web 项目 手动创建五个文件夹 2.选中 webapp 右键创建 JSP 文件。 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: fuyiweng Date: 2019-03-21 Time: 10:36 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%-- JSP page 配置指令 --%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%! String name; %&gt;&lt;!-- 变量声明 --&gt;request uri is &lt;%=request.getRequestURI() %&gt;&lt;!-- 内置对象的使用 --&gt;&lt;/br&gt;&lt;% name = &quot;abc&quot;; out.println(&quot;name is &quot; + name);%&gt;&lt;!-- JSP 脚本 --&gt;&lt;/body&gt;&lt;/html&gt; 在使用内置对象的时候，发现没有引用内置对象的方法；原因是没有引用 Tomcat 目录下的servlet-api.jar,jsp-api.jar 和 tomcat-api.jar 依赖。 引入依赖包 File-&gt; Project Structure-&gt; Libraries -&gt; 点加号，选择 java -&gt; 将Tomcat安装路径下lib文件夹下的servlet-api, jsp-api, tomcat-api 包导入 JSP 编译后的 Java 文件位置一般来说，编译后的 java 文件位置是在 Tomcat 目录下的/apache-tomcat-8.5.37/work/Catalina/localhost但我找不到我的编译文件。 『项目地址』：https://github.com/wengfe/JAVA/tree/master/JSPTest/src/main/webapp]]></content>
      <categories>
        <category>Java</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet 并发处理]]></title>
    <url>%2F2019%2F03%2F20%2FJava%2FServlet%2F2019-03-20%2F</url>
    <content type="text"><![CDATA[servlet 处理实现机制 客户端发送请求 -&gt; servlet 容器（Tomcat） -&gt; 调度器 -&gt; 在容器的线程池中选择一个工作组线程 -&gt; 执行 servlet A 的 service 方法 客户端发送第二条请求 -&gt; servlet 容器（Tomcat）-&gt; 调度器 -&gt; 在容器的线程池中选择第二个工作组线程 -&gt; 并发执行 servlet A 的 service 方法 当有线程执行完毕，返回线程池当线程池中的所有线程都在执行服务，新来的请求排队当超过了设置的最大排队数量的请求到来时，容器会拒绝处理新的请求 线程模型 总结特点 单实例 容器中的 servlet 只会初始化一次，所有针对该 servlet 的请求，都只有这一个实例实例对象 多线程 多个请求的处理是由多个线程完成的，可以同时进行处理 线程不安全 多线程共用一个单实例对象，因为没有默认加锁操作，所以会出现同时请求一个实例对象不同操作，造成数据不一致的情况。 线程安全变量线程安全 参数变量本地化 尽量使用局部变量，多线不共享局部变量 使用同步块 synchronized 对代码进行加锁处理，尽量缩小代码范围，不要在 service 方法中增加关键字，否则对性能损耗比较大 属性的线程安全 ServletContext 线程安全 多线程同时读写需要做数据同步的处理 HttpSession 理论上线程安全 只能在处理同一个用户的 Session 时，被访问；用户打开多个属于同一个进程的的浏览器窗口时，这些窗口的访问属于同一个 session 会出现多次请求。需要多个工作线程的处理，可能也会和出现多个线程的读写属性的问题 ServletRequest 线程安全 每一个请求只有一个工作线程处理，只能在同一个线程中被访问；所以安全 避免在 Servlet 中创建线程servlet 本身就是在多线程中进行处理的，在 servlet 中再创建线程；会造成运行情况复杂，更容易发生多线程安全问题。 多个 Servlet 访问外部对象加锁使用 synchronized 同步块进行加锁操作 创建一个 maven web-app 创建一个 SynchronizedTest 的 servlet 类 在 servlet 类中的 doGet 方法中使用 synchronized 标识进行加锁 在部署描述符中注册 SynchronizedServlet 类 12345678910111213141516171819202122232425262728public class SynchronizedServlet extends javax.servlet.http.HttpServlet &#123; String name; // 为引入线程不安全问题引入实例变量，不推荐使用实例变量 @Override public void init() throws ServletException &#123; super.init(); &#125; @Override public void destroy() &#123; super.destroy(); &#125; protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException &#123; //使用 synchronized 标识进行代码加锁 synchronized (this) &#123; name = request.getParameter(&quot;username&quot;);//从 url 中获取 username 的值 PrintWriter printWriter = response.getWriter(); // 创建 PrintWriter 对象，在页面中打印 try &#123; //为模拟大量并发 设置线程休眠时间。 Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; printWriter.print(&quot;username: &quot; + name); &#125; &#125;&#125; 『项目目录』：https://github.com/wengfe/JAVA/tree/master/SynchronizedTest/src/main]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器与监听器]]></title>
    <url>%2F2019%2F03%2F18%2FJava%2FServlet%2F2019-03-18-1%2F</url>
    <content type="text"><![CDATA[过滤器 Filter用于对用户请求进行预处理，和对请求响应进行后处理的 web 应用组件。 过滤源：请求与响应过滤规则：自定义过滤规则 过滤器工作原理 过滤器的应用场景 用户认证 编解码处理 请求数据压缩处理 过滤器生命周期过滤器的生成和销毁由 servlet 容器负责。 1.web-app 启动时，根据部署描述符的设置，创建 过滤器的实例对象，进行初始化。 在部署描述符中（web.xml），可对 filter 进行配置。 2.过滤操作， dofilter 方法； web-app 被移除，或服务器被停用；执行 destroy 方法。 过滤器的创建新建类继承 Filter 类，实现 Filter 类的 init, doFilter, destroy 方法。过滤器的创建和 servlet 差不多；都需要在 部署描述符（web.xml）中进行注册，配置： web.xml 注册 filter需在 节点之上。 123456789101112&lt;filter&gt; &lt;filter-name&gt;FilterTest&lt;/filter-name&gt; &lt;filter-class&gt;FilterTest&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;filterParam&lt;/param-name&gt; &lt;param-value&gt;111&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterTest&lt;/filter-name&gt; &lt;url-pattern&gt;/hello/world/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; java 创建 Filter 类：该 Filter 的作用是检查用户是否已经登录；若登录，跳转到 /hello/world 目录下否则跳转 index.html 页面 1234567891011121314151617181920212223public class FilterTest implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse resp, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, IOException &#123; System.out.println(&quot;filter doFilter method&quot;); HttpServletRequest request = (HttpServletRequest) req; HttpSession session = ((HttpServletRequest) req).getSession(); if (session.getAttribute(&quot;userName&quot;) == null )&#123; HttpServletResponse response = (HttpServletResponse) resp; response.sendRedirect(&quot;../index.html&quot;); &#125; else &#123; chain.doFilter(req,resp); &#125; &#125; public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException &#123; System.out.println(&quot;filter init method&quot;); String value = config.getInitParameter(&quot;filterParam&quot;); System.out.println(&quot;filter config param: &quot; + value); &#125;&#125; 过滤器链由多个过滤器组成。请求按照在部署描述符中注册的先后顺序进行请求的过滤。 1.当第一个过滤器的 doFilter 方法被调用的时候，servlet 容器创建一个代表 filter链的 filterChain 对象传递给该方法。2.在 doFilter 方法中如果开发调用了 filterChain 中的 doFilter 方法，servlet 容器会检查 filterchain 中是否还存在其他的 filter；若存在，继续调用 filter 方法；3.若不存在其他的 filter， servlet 会调用对应的目标资源；即最后一个 filter 方法请求的 servlet 资源对象。 监听器 Listener监听事件发生，在事件发生前后能够做出相应处理的 web 应用组件。 Listener实现了 javax.servlet.ServletContextListener 接口的服务器端程序；随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。且并不是直接注册在事件源上，而是由 servlet 容器负责注册，开发只需在部署描述符中进行配置，servlet 容器会自动将监听器注册到事件源中。 主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 web 监听器的分类按照监听对象划分： 监听应用程序环境（ServletContext） ServletContextListener ServletContextAttributeListener 监听用户请求对象（ServletRequest） ServletRequestListener ServletRequestAttributeListener 监听用户会话对象（HTTPSession） HttpSessionListener HTTPSessionAttributeListener HttpSessionActivationListener HttpSessionBindingListener 对对象的创建和销毁的监听ServletContextListener、ServletRequestListener、HttpSessionListener 对对象属相的监听ServletContextAttributeListener、ServletRequestAttributeListener、HTTPSessionAttributeListener 监听 Session 持久化到磁盘或从磁盘中重新加载到 JVM 中的监听器HttpSessionActivationListener 监听 Session 绑定和移除绑定的监听器HttpSessionBindingListener 监听器的应用场景 应用统计（针对 session 创建进行监听：用户登录统计 任务触发 业务需求 监听器的启动顺序与过滤器一致，依赖于在部署描述符的注册顺序。 监听器、过滤器、servlet 的启动顺序监听器 -&gt; 过滤器 -&gt; Servlet 监听器的创建在 web.xml 中创建 Listener监听器的创建只有一个子元素。在 与 节点之间。 123&lt;listener&gt; &lt;listener-class&gt;TestListener&lt;/listener-class&gt;&lt;/listener&gt; java 代码中创建 listener 继承类listener 类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@WebListener()public class TestListener implements ServletContextListener, ServletRequestListener, HttpSessionAttributeListener &#123; // Public constructor is required by servlet spec public TestListener() &#123; &#125; // ------------------------------------------------------- // ServletContextListener implementation // ------------------------------------------------------- public void contextInitialized(ServletContextEvent sce) &#123; /* This method is called when the servlet context is initialized(when the Web application is deployed). You can initialize servlet context related data here. */ System.out.println(&quot;listener: context init&quot;); &#125; public void contextDestroyed(ServletContextEvent sce) &#123; /* This method is invoked when the Servlet Context (the Web application) is undeployed or Application Server shuts down. */ System.out.println(&quot;listener: context destroy&quot;); &#125; public void attributeAdded(HttpSessionBindingEvent sbe) &#123; /* This method is called when an attribute is added to a session. */ System.out.println(&quot;listener: session attribute added&quot;); &#125; public void attributeRemoved(HttpSessionBindingEvent sbe) &#123; /* This method is called when an attribute is removed from a session. */ System.out.println(&quot;listener: session attribute removed&quot;); &#125; public void attributeReplaced(HttpSessionBindingEvent sbe) &#123; /* This method is invoked when an attibute is replaced in a session. */ System.out.println(&quot;listener: session attribute replaced&quot;); &#125; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println(&quot;listener: request destroy&quot;); &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println(&quot;listener: request init&quot;); &#125;&#125; 在其他类中调用调用 HttpSessionAttributeListener 方法。 123456if (name != null) &#123; System.out.println(&quot;second login: &quot; + name); session.removeAttribute(&quot;userName&quot;);//移除 attribue 调用 HttpSessionAttributeListener 的attributeRemoved 方法 &#125; session.setAttribute(&quot;userName&quot;, userName); 实例讲解在登录的时候新增了 Attribute，并在第二次登录的时候移除；且登录的同时也会新增 Attribute； 项目地址：https://github.com/wengfe/JAVA/tree/master/flitertest]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>filter</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转发与重定向]]></title>
    <url>%2F2019%2F03%2F18%2FJava%2FServlet%2F2019-03-18%2F</url>
    <content type="text"><![CDATA[请求转发使用：forward 方法流程：服务器将当前的request 和 response 对象交给指定的 web 组件处理转发与重定向对浏览器不透明，浏览器视角：一次请求一次响应；地址栏 url 不变。 服务器端流程： 获取转发对象 RequsetDispatcher 从当前请求中获取转发对象，通过 HttpServletRequest 实现； 通过servletContext 获取转发对象 调用 转发对象的 forward 方法； RequsetDispatcher 由 servlet 容器创建，封装一个由路径所标识的服务器资源。有两个比较常用的方法， forward 和 include ；include 方法让原组件和被转发到的组件都能输出响应信息 从当前请求中获取转发对象12RequestDispatcher rd = request.getRequestDispatcher(&quot;/servletFE&quot;);创建转发对象，设置转发路径rd.forward(request,response); // 转发 转发路径可以设置为绝对路径和相对路径，这里用的是绝对路径。 从 ServletContext 中获取转发对象有两种获取方式，分别是通过转发对象名和转发路径；这里只能使用绝对路径； 所以一般为了避免失误，我们在通过路径获取转发对象的时候一般都是用绝对路径的 1234// 通过servletContext 获取转发对象; 有两种方式获取转发对象 rd = this.getServletContext().getNamedDispatcher(&quot;ServletForwardEX&quot;); rd = this.getServletContext().getRequestDispatcher(&quot;/servletFE&quot;); rd.forward(request,response); // 转发 请求重定向通过 response 对象发送给浏览器一个新的 url 地址，让其重新请求；即 两次请求两次响应 通过原请求的响应对象进行重定向 1response.sendRedirect(&quot;servletRE&quot;);//设置请求重定向地址 重定向地址填写：相对路径：重定向到项目资源绝对路径：重定向到外部资源 总结浏览器地址栏变化请求范围 请求转发： 只能在同一个 web-app 中 重定向： 跨 web-app，服务器；重定位资源请求 请求过程 请求转发：一次请求一次响应 重定向： 两次请求两次响应 项目地址：https://github.com/wengfe/JAVA/tree/master/servletforward/src/main]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>重定向</tag>
        <tag>转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie与Session]]></title>
    <url>%2F2019%2F02%2F27%2FJava%2FServlet%2F2019-02-27%2F</url>
    <content type="text"><![CDATA[会话会话是一种持久网络协议，在用户（或用户代理）端和服务器端之间建立关联，从而起到交换数据包的作用机制。 Cookie会话数据保存在浏览器客户端 会话数据 保存在客户端 key-value 形式 工作流程识别返回用户包括三个步骤： 服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上，以备将来使用。 当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户。 cookie 的生命周期会话周期：cookie 数据保存在内存中，浏览器关闭后，会话失效。 setMaxAge 设置 cookie 有效期;默认 30 mincookie 数据保存在硬盘中，浏览器关闭后依然后效，直到超出有效期 cookie 缺陷大小和数量的限制：一般每个站点最多保存 20 个。大小在 4k 以内。 数据安全性：http 中的 cookie 为明文传递。 Session会话数据保存在服务器端session 在不同场合有不同的定义，此文主要为 HttpSession. 工作原理 客户端发送一条 http 请求到 服务器端； 服务器端生成一个 Session 对象，保存一些客户端数据到 Cookie 并与 SessionId 绑定，返回给客户端； 客户端再次发送一条包含 SessionId 的 http 请求，服务器端根据 SessionId 与服务器端保存的对象绑定。 Session 的生命周期setMaxInactiveInterval 设置有效期;默认 30 min通过部署描述符配置有效期主动调用接口使 session 失效； invalidate 接口。 部署描述符设置 session 失效时间；单位 min 123&lt;session-config&gt; &lt;session-timeout&gt;2&lt;/session-timeout&gt;&lt;/session-config&gt; 总结cookie： 明文存储 客户端 生命周期累计时间 每个站点 20 个 cookie，单个小于 4k session： 存放服务器端 生命周期间隔时间 存放于服务器端，避免大容量对象存储 项目地址： https://github.com/wengfe/JAVA/tree/master/COOKIEPROJECT]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet web.xml配置]]></title>
    <url>%2F2019%2F02%2F25%2FJava%2FServlet%2F2019-02-25%2F</url>
    <content type="text"><![CDATA[web.xml 文件位于 WEB-INF 目录下，被称为 部署描述符 XML 文件 设置 web 应用程序的组件部署信息 Servlet 容器需要支持部署描述符的所有元素 前两章包含部分的部署设置：Servlet 声明：1.一个servlet 支持多个 节点存在；2. 节点支持模糊匹配 123456789&lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;SimpleServlet&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/se&lt;/url-pattern&gt; &lt;url-pattern&gt;/se2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletMapping 匹配规则按优先级降级排序 精确路径匹配 最长路径匹配 扩展名匹配 default servlet 或者放弃 ServletConfig 配置下方在 servlet 节点内的 init-param , load-on-startup 节点为 ServletConfig 配置 init-param 为单个 servlet 配置的外部数据load-on-startup 为当前 Servlet 需要在容器初始化时就被加载所设置，多个 servlet 配置，按照配置的 参数正数大小顺序加载；不设置或设置为负数不会在容器初始化时加载。 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;SimpleServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;data1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;data2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/se&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletContext不依赖于容器，配置与 节点同级。供全局所有 servlet 使用。 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;SimpleServletTwo&lt;/servlet-name&gt; &lt;servlet-class&gt;SimpleServletTwo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServletTwo&lt;/servlet-name&gt; &lt;url-pattern&gt;/sese&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;context-param&gt; &lt;param-name&gt;globalData1&lt;/param-name&gt; &lt;param-value&gt;globalValue1&lt;/param-value&gt;&lt;/context-param&gt; 错误页面跳转1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.html&lt;/location&gt;&lt;/error-page&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet 3种数据配置数据配置]]></title>
    <url>%2F2019%2F02%2F21%2FJava%2FServlet%2F2019-02-21-1%2F</url>
    <content type="text"><![CDATA[http://localhost:8080/manager/html/tomcat 后台管理页面地址 servlet config 功能单个 servlet 中的数据配置。避免硬编码，将数据库账号密码等数据放在 web.xml 文件中。 Servlet 初始化过程中 参数将被封装到 ServletConfig 每个 Servlet 支持设置一个或者多个 以 Servlet 为单位，不是全局共享 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;SimpleServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;data1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;data2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/se&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在 web.xml 中添加 节点。init-param 需要放在 和 节点之下。 12345678 @Overridepublic void init() throws ServletException &#123; System.out.println(&quot;init method&quot;); ServletConfig config = this.getServletConfig(); String v1 = config.getInitParameter(&quot;data1&quot;); String v2 = config.getInitParameter(&quot;data2&quot;); System.out.println(&quot;v1 = &quot; + v1 + &quot;, v2 = &quot; + v2);&#125; 在 init 方法中创建 ServletConfig 参数来获取配置文件中的数据。 在多个 Servlet 中共享配置文件在多个 servlet 中共享配置文件，需要在 web.xml 中新增 context-param 节点。以下代码新增了一个 servlet 节点和两个共享配置。 12345678910111213141516&lt;context-param&gt; &lt;param-name&gt;globalData1&lt;/param-name&gt; &lt;param-value&gt;globalValue1&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;globalData2&lt;/param-name&gt; &lt;param-value&gt;globalValue2&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;SimpleServletTwo&lt;/servlet-name&gt; &lt;servlet-class&gt;SimpleServletTwo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServletTwo&lt;/servlet-name&gt; &lt;url-pattern&gt;/sese&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在 servlet 的 init 方法中获取 节点中保存的配置信息。 1234567891011121314 @Override public void init() throws ServletException &#123; System.out.println(&quot;init method&quot;);// super.init(); ServletConfig config = this.getServletConfig(); String v1 = config.getInitParameter(&quot;data1&quot;); String v2 = config.getInitParameter(&quot;data2&quot;); System.out.println(&quot;v1 = &quot; + v1 + &quot;, v2 = &quot; + v2);// 获取 context-param 中的配置数据 ServletContext context = this.getServletContext(); String gv1 = context.getInitParameter(&quot;globalData1&quot;); String gv2 = context.getInitParameter(&quot;globalData2&quot;); System.out.println(&quot;gv1 = &quot; + gv1 + &quot;, gv2 = &quot; + gv2); &#125; servlet 动态属性共享在不同的 Servlet 之间，动态共享数据。 setAttribute(key,value) getAttribute(key) 在第一个 servlet 类的 init 方法中通过 setAttribute 存入需要共享的键值对。 12ServletContext context = this.getServletContext();context.setAttribute(&quot;attribute1&quot;,&quot;111&quot;); 在第二个 servlet 类中的 init 方法中获取第一个 servlet 类中共享的值。 12ServletContext context = this.getServletContext();String attribute = (String) context.getAttribute(&quot;attribute1&quot;); 读取外部资源配置文件信息 ServletContext getResource getResourceAsStream getRealPath 1.首先创建工具类12345678910111213141516public class GeneralUtil &#123; public static String generateId()&#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); &#125; public static String getProperty(String key, InputStream in)&#123; Properties props = new Properties(); try &#123; props.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String value = props.getProperty(key); return value; &#125;&#125; 2.getResource 三种方法的实现123456789101112131415161718192021222324252627282930// getResource 方法 try &#123; URL url = context.getResource(&quot;/WEB-INF/classes/log4j.properties&quot;); InputStream in = url.openStream(); String propertyValue = GeneralUtil.getProperty(&quot;log4j.rootLogger&quot;,in); System.out.println(propertyValue); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;===============================================&quot;);// getResourceAsStream 方法，比较常用 省去了转换的过程 InputStream in2 = context.getResourceAsStream(&quot;/WEB-INF/classes/log4j.properties&quot;); String p2 = GeneralUtil.getProperty(&quot;log4j.rootLogger&quot;,in2); System.out.println(&quot;p2 &quot; + p2); System.out.println(&quot;===============================================&quot;);// getRealPath 方法 String path = context.getRealPath(&quot;/WEB-INF/classes/log4j.properties&quot;); System.out.println(&quot;Real path: &quot; + path); File f = new File(path); try &#123; InputStream in3 = new FileInputStream(f); String p3 = GeneralUtil.getProperty(&quot;log4j.rootLogger&quot;,in3); System.out.println(&quot;p3: &quot; + p3); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet初次使用-hello world]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2FServlet%2F2019-02-21%2F</url>
    <content type="text"><![CDATA[Servlet 介绍Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 一个 Servlet 就是一个 Java 类，并提供基于请求-相应模式的 web 服务。 Servlet 容器 装载和管理 Servlet 服务端程序 第一个 servlet 程序1. 新建 web 项目新建一个 project，选择 Java Enterprise -&gt; WebApplication -&gt; Application Server 中选择之前下载的 Tomcat 安装目录 1.2 创建项目，初始项目目录如下： 2.创建 servlet在 src 目录右键新建一个 servlet。 2.2 为 servlet 容器建名 2.3 成功创建 servlet 容器后的项目目录 2.4 在web/WEB-INF下创建两个文件夹：classes和libclasses用来存放编译后输出的class文件，lib用于存放第三方jar包。 打开 file -&gt; project Structure选择 Paths -&gt; 选择”Use module compile output path” -&gt; 将Output path和Test output path都选择刚刚创建的classes文件夹。 选择Dependencies -&gt; 将Module SDK选择为本机的jdk -&gt; 点击坐下的“+”号 -&gt; 选择1 “Jars or Directories” -&gt; 选择刚刚创建的lib文件夹 -&gt; 选择“jar directory” 部署servlet编辑在 WEB-INF 目录下的 web.xml 文件。新增 servlet 和 servlet-mapping 两个节点。 12345678&lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;SimpleServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/se&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 首先配置servlet。 这是使用元素完成的。 在这里给servlet一个名字，并写下servlet的类名。 其次，将servlet映射到URL或URL模式。 这在元素中完成。 在上面的例子中，所有以.html结尾的URL都被发送到servlet。 实现 servlet 类返回 src 目录下。 123456789101112131415161718public class SimpleServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;service method&quot;); super.service(req, resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;doGTE method&quot;); PrintWriter pw = resp.getWriter(); pw.print(&quot;hello world&quot;); pw.close();// super.doGet(req, resp); &#125;&#125; 运行 servlet控制台 打印 deployed successfully 就是部署成功了。 在 run congfig 配置项中可以看到 Tomcat 部署的 url 路径和端口号。 在浏览器中输入url + 端口号 + web.xml 配置的路径映射 页面显示 servlet 类中返回的数据，并且在控制台中也打印了日志。]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 基本命令]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2FMaven%2F2019-02-20-4%2F</url>
    <content type="text"><![CDATA[maven 基本命令mvn archetype:generate 使用模板生成项目mvn compile 编译源代码mvn test 单元测试mvn package 打包mvn deploy 部署mvn site 生成项目文档相关站点mvn cleanmvn install 安装相关插件 Tomcat 插件获取帮助文档:mvn help:describe -Dplugin=tomcat7 常见命令启动嵌入 Tomcat 实例 需要在 tomcat 项目目录下执行mvn tomcat:runmvn tomcat:deploymvn tomcat:undeploy 流程1.生成项目模板1mvn archetype:generate -DgroupId=com.netease.restrurant -DartifactId=Kitchen -Dpackage=com.netease -Dversion=1.0.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart 2.发布部署mvn tomcat:run 多项目管理]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置文件详解]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2FMaven%2F2019-02-20-3%2F</url>
    <content type="text"><![CDATA[pom.xml 配置文件翻译 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符--&gt; &lt;artifactId/&gt; &lt;!--被继承的父项目的全球唯一标识符--&gt; &lt;groupId/&gt; &lt;!--被继承的父项目的版本--&gt; &lt;version/&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用--&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。--&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt; &lt;maven/&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字，--&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL--&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息--&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum--&gt; &lt;system/&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt; &lt;url/&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt; &lt;notifier&gt; &lt;!--传送通知的途径--&gt; &lt;type/&gt; &lt;!--发生错误时是否通知--&gt; &lt;sendOnError/&gt; &lt;!--构建失败时是否通知--&gt; &lt;sendOnFailure/&gt; &lt;!--构建成功时是否通知--&gt; &lt;sendOnSuccess/&gt; &lt;!--发生警告时是否通知--&gt; &lt;sendOnWarning/&gt; &lt;!--不赞成使用。通知发送到哪里--&gt; &lt;address/&gt; &lt;!--扩展配置项--&gt; &lt;configuration/&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt; &lt;inceptionYear/&gt; &lt;!--项目相关邮件列表信息--&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt; &lt;mailingList&gt; &lt;!--邮件的名称--&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL--&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表--&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息--&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符--&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名--&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email--&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL--&gt; &lt;url/&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织--&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL--&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等--&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表--&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素--&gt; &lt;contributor&gt; &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt; &lt;license&gt; &lt;!--license用于法律上的名称--&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL--&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息--&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt; &lt;tag/&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt; &lt;organization&gt; &lt;!--组织的全名--&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL--&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;sourceDirectory/&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt; &lt;scriptSourceDirectory/&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;testSourceDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。--&gt; &lt;outputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。--&gt; &lt;testOutputDirectory/&gt; &lt;!--使用来自该项目的一系列构建扩展--&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。--&gt; &lt;extension&gt; &lt;!--构建扩展的groupId--&gt; &lt;groupId/&gt; &lt;!--构建扩展的artifactId--&gt; &lt;artifactId/&gt; &lt;!--构建扩展的版本--&gt; &lt;version/&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt; &lt;defaultGoal/&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt; &lt;targetPath/&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt; &lt;filtering/&gt; &lt;!--描述存放资源的目录，该路径相对POM路径--&gt; &lt;directory/&gt; &lt;!--包含的模式列表，例如**/*.xml.--&gt; &lt;includes/&gt; &lt;!--排除的模式列表，例如**/*.xml--&gt; &lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录--&gt; &lt;directory/&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt; &lt;finalName/&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt; &lt;filters/&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt; &lt;extensions/&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息--&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id/&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase/&gt; &lt;!--配置的执行目标--&gt; &lt;goals/&gt; &lt;!--配置是否被传播到子POM--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表--&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt; &lt;id/&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志--&gt; &lt;activeByDefault/&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt; &lt;jdk/&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字--&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;)--&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本--&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt; &lt;property&gt; &lt;!--激活profile的属性的名称--&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值--&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。--&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。--&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素--&gt; &lt;build&gt; &lt;defaultGoal/&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素--&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports/&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素--&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素--&gt; &lt;properties/&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息--&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载--&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled/&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt; &lt;updatePolicy/&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt; &lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称--&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID--&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID--&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt; &lt;excludeDefaults/&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt; &lt;outputDirectory/&gt; &lt;!--使用的报表插件和他们的配置。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息--&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--报表插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的报表插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--报表插件的配置--&gt; &lt;configuration/&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到--&gt; &lt;id/&gt; &lt;!--产生报表集合时，被使用的报表的配置--&gt; &lt;configuration/&gt; &lt;!--配置是否被继承到子POMs--&gt; &lt;inherited/&gt; &lt;!--这个集合里使用到哪些报表--&gt; &lt;reports/&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt; &lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt; &lt;layout/&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout/&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息--&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称--&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt; &lt;downloadUrl/&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt; &lt;relocation&gt; &lt;!--构件新的group ID--&gt; &lt;groupId/&gt; &lt;!--构件新的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--构件新的版本号--&gt; &lt;version/&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt; &lt;message/&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt; &lt;status/&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt; &lt;properties/&gt; &lt;/project&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat简介]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2FTomcat%2F2019-02-20-2%2F</url>
    <content type="text"><![CDATA[启动 类 liunx $CATALINA_HOME/bin/startup.sh $CATALINA_HOME/bin/catalina.sh start windows %CATALINA_HOME%\bin\startup.bat %CATALINA_HOME%\bin\catalina.bat start 关闭 类 liunx $CATALINA_HOME/bin/shutdown.sh $CATALINA_HOME/bin/catalina.sh stop windows %CATALINA_HOME%\bin\shutdown.bat %CATALINA_HOME%\bin\catalina.bat stop 提供资源 HTML 静态资源 动态资源，Servlet jvm 启动参数配置通过环境比那辆 JAVA_OPTS常见参数 -server -Xms512m -Xmx512mexport JAVA_OPTS=&quot;-server --Xms2048m -Xmx2048m&quot; Tomcat 架构 Connector 由 Coyote 实现多种不同的 connector 默认 BIO Connector 阻塞式 Web Container 由 Catalina 实现 ##请求处理流程 Connector 参数配置 port address protocol connectionTimeout acceptCount 线程排队队列长度；超出链接被拒 maxConnections 最大连接数（线程池最大数） 配置线程池项 minSpareThreads maxThreads Tomcat 日志作用： Tomcat 运行情况获知。 调试工具 日志分类 系统运行日志 访问日志 应用日志 日志配置 server.xml123&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; directory 日志目录路径（Tomcat 安装路径）prefix 日志名前缀suffix 日志名后缀pattern 日志格式 日志按小时滚动：fileDateFormat=”yyyy-MM-dd.HH.”rotatable=”true” 部署手动部署将工程文件手动复制到 webapp 目录下。 war 包1.进入项目根目录，输入命令行。jar cvf project_name.war .2.将war 包移动到 webapp 目录下]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 协议简介]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2FTomcat%2F2019-02-20-1%2F</url>
    <content type="text"><![CDATA[HTTP协议请求响应式协议，一次请求和一次响应构成一次HTTP事务。HTTP 协议是无状态的，任何两次请求都是没有依赖关系的。 协议分层-基于 IP 协议栈HTTP 应用层TCP 传输层 80 端口 保证传输数据有序可靠IP 网络层 IP &lt;- 域名服务器（DNS）&lt;- 域名（www.XXX.com） 数据链路层和物理层 数据传输 流程 请求分析1234567 GET /upload/iou/APP_FILE/ylzg-resource.zip?auth_key=1548988144918-9b872976b9564a6930b8c7df6c1dbaaf HTTP/1.1Host yltest.xylpay.comAccept */*Accept-Language zh-cnConnection keep-aliveAccept-Encoding br, gzip, deflateUser-Agent ylzg-qa/4.0.6.2 CFNetwork/902.2 Darwin/17.7.0 请求行 请求方法 请求路径 协议版本号 请求头 key-value 键值对 常见请求头 Host, Connection, User-Agent 等 请求体 请求体是可选的 响应格式123456789101112131415161718HTTP/1.1 200 &lt;!--状态行--&gt;Server: nginx/1.9.3Date: Fri, 01 Feb 2019 06:31:11 GMTContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedVary: Accept-EncodingX-Application-Context: gateway-portal:QA,test:8041X-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockCache-Control: no-cache, no-store, max-age=0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYX-Ab-Gray: stableContent-Encoding: gzipConnection: keep-alive&#123;&quot;content&quot;:[&#123;...&#125;]&#125;&lt;!--响应体内容--&gt; 状态码：200 ok 304 Not Modified 3% 缓存相关 404 Not Found 500 Internal Server Error 服务器内部错误 响应头 key:valueServer 服务器使用的应用程序返回内容（Web 服务器）Content-Type 内容类型；音频 HTML 视频等Content-Length 内容长度（为一次链接多次请求适配） 相应体 与响应头空行分割 \r\n 可以是文本或二进制 大小由响应头中的 Content-Length 指定]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 的继承-子类与父类之间的复杂关系]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2FJava2E%2F2019-02-20%2F</url>
    <content type="text"><![CDATA[调用子类，先进行父类的参数定义和构造器构造，再进行子类的参数定义和构造器构造；如果子类构造器中没有 super() 语句，或 super() 语句中不含参数；会去寻找父类当中不含参数的构造器；有参数时，寻找有对应参数的父类构造器； 父类中的函数 protected 参数声明，尽量少用，可以通过父类构造函数使用父类中 private 参数； #转型 ##向上转型父类定义了通用的属性和方法；不同的子类继承后可以直接使用；不用重复写。概念：子类的对象当做父类的对象用Father f = new Child()向上造型是默认的，不需要运算符向上造型总是安全的 子类的变量不能接收父类的对象实例父类的变量能接收子类的对象实例 向上造型时，子类重写的父类方法的权限要大于等于父类方法；返回类型需一致。 向下转型父类对象想使用子类特有的方法时向下造型一般来说是不安全的；但是通过声明造型，可以强制通过Child c = (Child)f instanceof向下转型时，若父类对象不是子类对象的实例，就会发生 ClassCastException 异常；所以在转型时，需要使用 关键字 instanceof 来判断。child instance Fatherchild : 子类对象Father: 父类返回值: 布尔]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 的输入输出]]></title>
    <url>%2F2019%2F02%2F18%2FJava%2FJava2E%2F2019-02-18-3%2F</url>
    <content type="text"><![CDATA[处理输入输出的方式称为流。 Stream（流）的特性是一维的，单方向的。 流的基础类InputStreamOutputStream 标准输入/出流字节层面的流传输。 System.out.println(“Text”) System.in 1Scanner in = new Scanner(System.in)； 文件流字节层面的流传输。FileOutputStreamFileInputStream FileOutputStream 示例： 1234567891011121314151617181920public class File_Stream &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); byte[] buf = new byte[10]; for (int i=0; i&lt;buf.length;i++)&#123; buf[i] = (byte)i; &#125; try &#123; FileOutputStream out = new FileOutputStream(&quot;a.dat&quot;); out.write(buf); out.close(); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 流过滤器以介质流对象为基础层构建过滤器流，最终形成的流对象能在数据的输入输出过程中，逐层使用过滤器流的方法来读写数据。 DataInput(Output)Stream 类可以进行基本数据类型的传输。 （字节流）fileInpitStream | bufferedInputStream | DataInputStream | 基本数据类型 下文代码就增加了 buffer 和 data 两个流过滤器。因为流过滤器需要在文件流的基础上进行再次封装，所以引用文件流程的代码进行修改： 12345678910try &#123; DataOutputStream out = new DataOutputStream( new BufferedOutputStream( new FileOutputStream(&quot;b.dat&quot;)));// FileOutputStream out = new FileOutputStream(&quot;a.dat&quot;);// out.write(buf); int i = 0xcafebabe; out.writeInt(i); out.close(); &#125; 需要注意的是 DataOutputStream 是将存储在内存中的数据，保存到文件中；并没有转换成自然语言，所以读取也需要通过相应的方式进行 DataInputStream的 封装； 12345678910111213141516try &#123; DataOutputStream out = new DataOutputStream( new BufferedOutputStream( new FileOutputStream(&quot;b.dat&quot;)));// FileOutputStream out = new FileOutputStream(&quot;a.dat&quot;);// out.write(buf); int i = 0xcafebabe; out.writeInt(i); out.close(); DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(&quot;b.dat&quot;))); int j = in.readInt(); System.out.println(j); &#125; 文本流Reader/Writerreader/Writer 本身是处理 Unicode 字符的。但在使用场景上，因为有多种文本编码格式，所以需要借助流来打开文件，用流过滤器来建立 Reader/Writer 来进行输入和输出。 123456789101112131415161718// Reader/Writer PrintWriter out_p = new PrintWriter( new BufferedWriter(// OutputStreamWriter 构建了 Stream 和 Writer 之间的桥梁 new OutputStreamWriter( new FileOutputStream(&quot;a.txt&quot;)))); int k = 123456;// 文本流中的 print 表示打印到文件中？ out_p.print(k); out_p.close();// 读文件 BufferedReader in_r = new BufferedReader( new InputStreamReader( new FileInputStream(&quot;src/../a.txt&quot;))); String line; while ((line=in_r.readLine()) != null)&#123; System.out.println(line); &#125; 常用 BufferedReader 来读文件， readLine()来获取内容。LineNumberReader 读文件可以得到行号， getLineNumber()。 FileReader InputStreamReader 的子类，所有方法都从父类中继承而来。 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新的 FileReader FileReader 不能指定编码转换方式。 格式化输入输出输出PrintWriter format(“格式”，。。。); printf(“格式”，。。。); print(各种基本类型); println(各种基本类型); 输入Scnner 在 InputStream 或 Reader 上简历一个 Scanner 对象可以从流中文本解析出以文本表达的各种基本类型 next…() 流的应用使用 sicket 活的流数据。本地调式需在 mac 本地输入命令 nc -l 12345 1234567891011121314151617181920212223242526public class SocketStream &#123; public static void main(String[] args) &#123; try &#123; Socket socket = new Socket(InetAddress.getByName(&quot;localhost&quot;),12345); PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream()))); out.println(&quot;Hello&quot;);// 若不刷新缓存，服务端不会显示 hello out.flush(); BufferedReader reader = new BufferedReader( new InputStreamReader( socket.getInputStream())); String line; while ((line=reader.readLine())!=null) &#123; System.out.println(line); &#125; out.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 因为 read()函数是阻塞的，在督导所需的内容之前会停下来 使用read() “高级”的函数，入nextInt()、readLine()都是同样的 所以常用单独的线程来做 socket 读的等待，或使用 nio 的channel 选择机制 对于socket，可以设置 SO 时间 setSoTimeout(int timeOut) 对象串行化对象通过写出描述自己状态的数值来记录自己 ，这个过程叫对象的串行化(Serialization) 。串行化的主要任务是写出对象实例变量的数值。如果变量是另一对象的引用，则引用的对象也要串行化。这个过程是递归的，串行化可能要涉及一个复杂树结构的单行化，包括原有对象、对象的对象、对象的对象的对象等等。对象所有权的层次结构称为图表(graph)。 自己写的类对象写到文件里。 ObjectInpuStream 类 readObject() ObjectOutputStream 类 writeObject() Serializable 接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Student implements Serializable &#123; private String name; private int age; private int grade; public Student(String name, int age, int grade) &#123; this.name = name; this.age = age; this.grade = grade; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, grade=&quot; + grade + &apos;&#125;&apos;; &#125;&#125;public class ObjectStream &#123; public static void main(String[] args) &#123; try &#123; Student s1 = new Student(&quot;John&quot;,18,8); System.out.println(s1);// obj stream 写到文件 ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;obj.dat&quot;)); out.writeObject(s1); out.close();// obj stream 读 ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;src/../obj.dat&quot;)); Student s2 = (Student) in.readObject(); System.out.println(s2); in.close(); System.out.println(s1==s2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 读回来的虽然内容一致，但对象新造的不同对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三讲 事务隔离：为什么你改了我还看不见]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%9345%E8%AE%B2%2F2019-02-18-2%2F</url>
    <content type="text"><![CDATA[提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。 转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。 以InnoDB为例，剖析 MySQL 在事务支持方面的特定实现，并基于原理给出相应的实践建议。 隔离性和隔离级别事务涉及到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），这里来说说其中 I ，也就是“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。 首先明确一点，隔离级越高，效率越低。因此，需要在二者之间寻找一个平衡。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。逐一解释： 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 新数据存在内存里，InnoDB buffer poo 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 各级别效果假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。 12mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1); 事务A 事务B 启动事务查询得到值 1 启动事务 查询得到值 1 将 1 改成 2 查询得到值 V1 提交事务B 查询得到值 V2 提交事务 A 查询得到值 V3 在不同的隔离级别下，事务A会有哪些不同的返回结果，V1、V2、V3的返回值分别是什么。 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。 读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。串行：我的事务尚未提交，别人就别想改数据。这4种隔离级别，并行性能依次降低，安全性依次提高。 重复读和读提交的性能差异 建立视图没什么成本的，就是拷贝一个事务数组；所以性能的差异不是体现在这里；一般我们说可重复的效率相对的低（其实也还好，不会低多少），主要还是因为可重复读的锁范围可能更大（有gap lock），锁时间更长（事务结束才释放），影响并发度 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。在“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；在“串行化”隔离级别下直接用加锁的方式来避免并行访问。 我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。 配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED 。可以用 show variables 来查看当前的值。 1234567891011mysql&gt; show variables like &apos;transaction_isolation&apos;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 可重复读级别的应用总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，根据自己的业务情况来定。如需要“可重复读”的场景。 一个数据校对逻辑的案例。 假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。 这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。 事务隔离的实现再来看看事务隔离具体是怎么实现的。这里展开说明“可重复读”。 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 假设一个值从 1 被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。 基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。 事务的启动方式如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种： 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。 有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。 因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。 但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。 在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。 1select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 小结介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二讲 一条 sql 更新语句的执行]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%9345%E8%AE%B2%2F2019-02-18-1%2F</url>
    <content type="text"><![CDATA[通过对一句 updata 语句，来解析 Mysql 的日志系统。 例如我们创建了表 T, 如下命令： 1mysql&gt; create table T(ID int primary key, c int); 更新语句： 1mysql&gt; update T set c=c+1 where ID=2; 更新语句也会同查询语句一样，通过连接器、分析器、优化器、执行器；最后到达存储引擎。 流程执行语句前要先连接数据库，这是连接器的工作。 在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也是一般不建议使用查询缓存的原因。 接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL ，那这两个词肯定是绕不过的。redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到自己的程序里 redo log举个例子：酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。如果有人要赊账或者还账的话，掌柜一般有两种做法： 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉； 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。 在生意红火柜台很忙时，掌柜会选择后者，因为前者操作实在是太麻烦了。得找到这个人的赊账总额那条记录，找到之后再拿出算盘计算，最后再将结果写回到账本上。 相比之下，还是先在粉板上记一下方便。如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？ MySQL 中 WAL 技术同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。 而粉板和账本配合的整个过程，其实就是MySQL里经常说到的 WAL 技术，WAL的全称是 Write-Ahead Logging ，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。 具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。 如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。 与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。 write pos 是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint ，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 有了 redo log ，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe 。 要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。 binlog前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。 Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。 为什么会有两份日志呢？因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是 MyISAM ，但是MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 这两种日志有以下三点不同。 redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。 执行器先找引擎取 ID=2 这一行。 ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上1，比如原来是 N ，现在就是 N+1 ，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog ，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。 你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤： prepare 和 commit ，这就是”两阶段提交”。 两阶段提交为了让两份日志之间的逻辑一致。 1 prepare阶段 -&gt; 2 写binlog -&gt; 3 commit当在2之前崩溃时重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。一致当在3之前崩溃重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致 怎样让数据库恢复到半个月内任意一秒的状态？binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog ，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 为什么日志需要“两阶段提交”。这里用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的update语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0 ，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？ 先写 redo log 后写 binlog 。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。 先写 binlog 后写 redo log 。如果在 binlog 写完之后 crash ，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是0。但是 binlog 里面已经记录了 “把c从0改成1” 这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是1，与原库的值不同。 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？ 其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 小结通过更新语句，介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog 。 redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。 sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数建议设置成1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。 问题文章的最后，留下的问题是一天一备跟一周一备的对比。 好处是“最长恢复时间”更短。 在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份。 一周一备最坏情况就要应用一周的binlog了。 系统的对应指标就是提到的RTO（恢复目标时间）。 当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，就需要你根据业务重要性来评估了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一讲 一条 sql 查询语句的执行]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%9345%E8%AE%B2%2F2019-02-18%2F</url>
    <content type="text"><![CDATA[通过对一句 select 语句，来解析 Mysql 的基础架构。 1mysql&gt; select * from T where ID=10; 语句拆解语句在 MySQL 的各个功能模块中的执行过程： 大体来说，MySQL可以分为Server层和存储引擎层两部分。 Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。 在 create table 建表的时，未指定引擎类型，默认使用 InnoDB 。在 create table语句中使用 engine=memory, 来指定使用内存引擎创建表。从图中不难看出，不同的存储引擎共用一个 Server 层。 模块功能解析连接器连接器负责跟客户端建立连接、获取权限、维持和管理连接。 连接器示例：1.输入命令mysql -h$ip -P$port -u$user -p2.交互对话里面输入密码。直接在步骤1 -p 参数后输入命令，可能会密码泄露。所以一般在命令后单独输入 步骤解释：命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。 12345678910mysql&gt; show processlist;+----+------+-----------------+------+---------+------+----------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+-----------------+------+---------+------+----------+------------------+| 4 | root | localhost:62435 | test | Query | 0 | starting | show processlist || 10 | root | localhost:62436 | test | Sleep | 16 | | NULL |+----+------+-----------------+------+---------+------+----------+------------------+2 rows in set (0.00 sec) mysql&gt; 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。 如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。如果要继续连接数据库，需要重连，然后再执行请求了。 长连短连数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。 怎么解决这个问题呢？你可以考虑以下两种方案。 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存连接建立后，就开始执行 select 语句。执行逻辑开始进行第二步：查询缓存。 MySQL拿到一个查询请求后，会先去查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存失效频繁只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 指定是否查询缓存MySQL 提供了“按需使用”的方式。可以将参数 query_cache_type 设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样： 1mysql&gt; select SQL_CACHE * from T where ID=10； 需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。 分析器若是未命中查询缓存（或是 MySQL 8.0 后的版本），就要真正执行语句。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。 分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。 123mysql&gt; elect * from t where ID=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1 一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。 ###优化器经过了分析器，MySQL就知道这条 sql 语句是要做什么了。但在开始执行之前，还要先经过优化器的处理。 优化器是在表里存在多个索引时，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。 两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。优化器是怎么选择索引的，有没有可能选择错等等，会在后面的文章中展开说明优化器的内容。 执行器MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，第三步就进入了执行器阶段，开始执行语句。 开始执行的时，会判断用户对这个表 T 是否有执行查询的权限。如果没有，就会返回权限错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 123mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user &apos;b&apos;@&apos;localhost&apos; for table &apos;T&apos; 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的： 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。 在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。 小结介绍了MySQL的逻辑架构，对一个 SQL 语句完整执行流程的各个阶段，有一个初步的印象。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 服务器数据库创建]]></title>
    <url>%2F2018%2F12%2F20%2FJava%2FJava2E%2F2018-12-20%2F</url>
    <content type="text"><![CDATA[查看服务器数据库show databases; 创建库CREATE DATABASE database_name; 使用库use database_name;查看数据库内的表show tables; 创建表 12345create table table_name(key1 int(12),key2 char(12)); 表名重命名alter table name1 rename as name2;字段重命名alter table table_name change t_name t_name_new varchar(20); 插入表记录 123insert into table_name(key1,key2,key3) values(01,&apos;name1&apos;,value1);insert into table_name values(02,&apos;name2&apos;,value2);insert into table_name(key1,key2) values(03,&apos;name3&apos;);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 接口初解]]></title>
    <url>%2F2018%2F12%2F17%2FJava%2FJava2E%2F2018-12-17%2F</url>
    <content type="text"><![CDATA[接口接口：纯抽象类 * 所有成员函数都是抽象函数 * 所有成员变量都是 public static final * 方法都是共有的 12345[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法 [可见度] 返回类型 接口名称()；&#125; 类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 1.接口可以多继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 2.接口的方法声明必须是 public abstract 即便不写默认也是 3.接口里面不能包含方法的实现主体 4.类继承接口必须实现接口里申明的全部方法，除非该类是抽象类 5.类里面可以声明 public static final 修饰的变量 6.接口不能被实例化，但是可以被实现类创建 7.接口没有构造方法。 8.接口中所有的方法必须是抽象方法。 抽象函数/抽象类抽象类：表达概念而无法构造出实体对象的类抽象方法:表达概念而无法实现具体代码的函数 特点： 带有 abstract 修饰符的函数 有抽象函数的类一定是抽象类 抽象类不能制造对象 但是可以定义变量 任何集成了抽象类的非抽象类对象可以付给这个变量。 抽象类的子类必须付给父类中的所有抽象函数，否则子类也会变成抽象类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JAVA接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 城堡游戏（代码优化思想）]]></title>
    <url>%2F2018%2F12%2F14%2FJava%2FJava2E%2F2018-12-14%2F</url>
    <content type="text"><![CDATA[城堡中有多个房间，用户通过输入north, south, east, west等来确认去哪一个房间（此时窗口会有提示转到哪个房间），如果此时多出一个房间，需要使用up, down才能到达，修改代码则需要代码具有可扩展性，对原来的代码进行优化来实现这个功能。 优化前代码结构： 优化路程将类中相同的代码抽离，转为一个公用的方法将注释的代码抽离成一个方法，供调用： 123456789101112131415private void nowRoom()&#123; System.out.println(&quot;现在你在&quot; + currentRoom); System.out.print(&quot;出口有：&quot;);// 将出口信息封装在Room类中，降低程序之间的耦合// if(currentRoom.northExit != null)// System.out.print(&quot;north &quot;) ;// if(currentRoom.eastExit != null)// System.out.print(&quot;east &quot;);// if(currentRoom.southExit != null)// System.out.print(&quot;south &quot;);// if(currentRoom.westExit != null)// System.out.print(&quot;west &quot;); System.out.println(currentRoom.getExitDesc()); System.out.println(); &#125; 将 Room 类中的变量转为私有变量Room 类和 Game 类有大量的代码出口相关，Game 类中大量使用了 Room 类中的成员变量；利用封装来降低类和类之间的耦合；便于代码后续的维护。 在将 Room 类的变量转为私有后，发现 Game 类中有几处报错；说明 Game 类中调用到了 Room 类的成员变量；第一处是上一步中提取的方法，阅读代码功能；是显示当前 Room 的出口信息。 优化思想：调用者不做被调用类的逻辑处理出口信息能否只在 Room 中做逻辑处理，Game 类中只负责调用就好。 做法：在 Room 类中增加 getExitDesc 方法。 1234567891011121314 public String getExitDesc()&#123;// 使用 StringBuffer 是因为 String 对象是管理者，每次对 String 对象的修改都是新增一个 String 对象，// 对系统开销比较大，但是 StringBuffer支持修改 StringBuffer sb = new StringBuffer(); if (northExit != null) sb.append(&quot;north &quot;); if (eastExit != null) sb.append(&quot;east &quot;); if (westExit != null) sb.append(&quot;west &quot;); if (southExit != null) sb.append(&quot;south &quot;); return sb.toString(); &#125; 这样在 Game类中的 nowRoom 方法中，只需要调用 getExitDesc 方法就能返回出口信息。 第二处错误是在 Game 类中， goRoom 方法中，显示的是玩家进入下一个房间后，显示出口信息。同样的，想办法让 Room 类中就处理其中的逻辑，直接返回给 Game 类下一个房间的出口信息。 在 Room 类中新增一个 getExit 方法，直接将 Game 类中的逻辑处理复制过来用。 12345678910111213141516public Room getExit(String direction)&#123; Room ret = null; if(direction.equals(&quot;north&quot;)) &#123; ret = northExit; &#125; if(direction.equals(&quot;east&quot;)) &#123; ret = eastExit; &#125; if(direction.equals(&quot;south&quot;)) &#123; ret = southExit; &#125; if(direction.equals(&quot;west&quot;)) &#123; ret = westExit; &#125; return ret;&#125; 减少代码中的硬编码优化思想：使用容器来代替硬编码Room 类有四个成员变量表示四个方向。使用 HashMap 容器来装载方向，这样方便以后新增方向变量，提高代码灵活性。 做法：去掉原有变量，新增一个 HashMap 容器变量。private HashMap&lt;String,Room&gt; exit = new HashMap&lt;String,Room&gt;();同步修改类方法中的 setExits 方法。因为使用了容器的原因，所以只能为 Room 对象一个个出口添加。 12345// 录入房间空间位置的方式改变，由原来的对一个房间的四个方向分别定义，改为对一个房间// 自定义方向以及该方向上的新房间public void setExit(String dir, Room room)&#123; exit.put(dir,room); &#125; 发现 Room类 中的 getExit 方法出现报错，可以通过容器直接返回房间的方向信息： 12345678910111213141516public Room getExit(String direction)&#123;// Room ret = null;// if(direction.equals(&quot;north&quot;)) &#123;// ret = northExit;// &#125;// if(direction.equals(&quot;east&quot;)) &#123;// ret = eastExit;// &#125;// if(direction.equals(&quot;south&quot;)) &#123;// ret = southExit;// &#125;// if(direction.equals(&quot;west&quot;)) &#123;// ret = westExit;// &#125; return exits.get(direction); &#125; getExitDesc 方法也要同步做修改，var.keyset() 方法获取 map 的 key 的集合。 123456789101112131415161718public String getExitDesc()&#123;// 使用 StringBuffer 是因为 String 对象是管理者，每次对 String 对象的修改都是新增一个 String 对象，// 对系统开销比较大，但是 StringBuffer支持修改 StringBuffer sb = new StringBuffer(); for (String dir : exits.keySet()) &#123; sb.append(dir+&quot; &quot;); &#125;// if (northExit != null)// sb.append(&quot;north &quot;);// if (eastExit != null)// sb.append(&quot;east &quot;);// if (westExit != null)// sb.append(&quot;west &quot;);// if (southExit != null)// sb.append(&quot;south &quot;); return sb.toString(); &#125; 因为修改了 Room 类中的房间出口信息设置方法，Game 类中的 creatRooms 方法报错。 1234567891011121314151617181920212223242526272829private void createRooms() &#123; Room outside, lobby, pub, study, bedroom; // 制造房间 outside = new Room(&quot;城堡外&quot;); lobby = new Room(&quot;大堂&quot;); pub = new Room(&quot;小酒吧&quot;); study = new Room(&quot;书房&quot;); bedroom = new Room(&quot;卧室&quot;); // 初始化房间的出口// outside.setExits(null, lobby, study, pub);// lobby.setExits(null, null, null, outside);// pub.setExits(null, outside, null, null);// study.setExits(outside, bedroom, null, null);// bedroom.setExits(null, null, null, study); outside.setExit(&quot;eastExit&quot;,lobby); outside.setExit(&quot;southExit&quot;,study); outside.setExit(&quot;westExit&quot;,pub); lobby.setExit(&quot;westExit&quot;,outside); pub.setExit(&quot;eastExit&quot;,outside); study.setExit(&quot;northExit&quot;,outside); study.setExit(&quot;eastExit&quot;,bedroom); bedroom.setExit(&quot;westExit&quot;,study); currentRoom = outside; // 从城堡门外开始 &#125; 到这里，如果想要增加一个新的出口信息，只要在 Game 类中初始化一个新的房间，增加新的出口信息类型就可以了； 以框架+数据来提高可扩展性优化思想：将硬编码改成 框架 + 数据城堡游戏中 main 函数中的 go,help,bye 三个命令解析，依旧是硬编码的；优化成框架和数据的形式。 优化做法： 命令的解析脱离 if-else 定义一个 Handle 来处理命令 用 Hash 表来保存命令和 Handler 之间的关系 字符串对应关系用 HashMap[为什么字符串对应一个东西通常都是用 HashMap？] 定义一个 HashMap，key 和 value 都必须是对象，城堡游戏中有的是，String 和调用一个函数。因此需要创建一个中间类 Handle，通过 handle 类的对象调用对应的函数。如下创建四个类。 12345678910111213141516171819202122232425262728293031323334353637383940//父类 Handlerpublic class Handler &#123; public void doCmd(String word)&#123; &#125; public boolean isBye() &#123; return false; &#125;&#125;// HandlerGopublic class HandlerGo extends Handler &#123; private Game game; public HandlerGo(Game game)&#123; this.game = game; &#125; @Override public void doCmd(String word) &#123; game.goRoom(word); &#125;&#125;// HandlerHelppublic class HandlerHelp extends Handler &#123; @Override public void doCmd(String word) &#123; System.out.println(&quot;迷路了吗？你可以做的命令有：go bye help&quot;); System.out.println(&quot;如：\tgo east&quot;); &#125;&#125;// handlerByepublic class HandlerBye extends Handler&#123; @Override public boolean isBye() &#123; return true; &#125;&#125; 在 Gmae 类初始化 Handle 类的 HashMap 对象，并在构造器中构建 不同功能的 Handle 对象放入 map 中； 1234567891011121314public class Game &#123; private Room currentRoom; /*用Hash表保存命令与Handler之间的关系*/ private HashMap&lt;String, Handler&gt; handlers = new HashMap&lt;String, Handler&gt;(); public Game() &#123; handlers.put(&quot;go&quot;, new HandlerGo(this)); handlers.put(&quot;bye&quot;, new HandlerBye()); handlers.put(&quot;help&quot;,new HandlerHelp()); createRooms(); &#125; ... 将原来 main 函数中的循环体，提取成一个新的方法： 12345678910111213141516171819202122232425262728293031public void play()&#123; Scanner in = new Scanner(System.in); while ( true ) &#123; String line = in.nextLine(); String[] words = line.split(&quot; &quot;);// 利用Hash表&lt;K, V&gt;的特性，如果用户输入&quot;bye&quot;，通过handler.get()得出handler// 类型下面这句就相当于：Handler handler = new HandlerBye(); Handler handler = handlers.get(words[0]); String value = &quot; &quot;; if (words.length &gt; 1)&#123; value = words[1]; &#125; if (handler != null)&#123;// 此时handler为HandlerBye型，没有value值 handler.doCmd(value);// HandlerBye继承了Handler中的isBye()方法并将其覆盖，此时handler.isBye()返回true if (handler.isBye())&#123; break; &#125; &#125;// if ( words[0].equals(&quot;help&quot;) ) &#123;// game.printHelp();// &#125; else if (words[0].equals(&quot;go&quot;) ) &#123;// game.goRoom(words[1]);// &#125; else if ( words[0].equals(&quot;bye&quot;) ) &#123;// break;// &#125; &#125; in.close(); &#125; 优化完成，代码运行正常；优化完成后，当需要新增动作命令时，只需要新增一个 handler类型，并在构造器里新增新类型的 map 键值对。而不用对 play 函数做改动。这就是通过 框架 + 数据 实现的可扩展性。 github代码地址 https://github.com/wengfe/JAVA/tree/master/castle简书地址：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 加密]]></title>
    <url>%2F2018%2F09%2F02%2FPython%2F2018-09-02%2F</url>
    <content type="text"><![CDATA[关于Python加密1.简单的用base64模块这个是Python标准库里面的模块，用来做一个二进制的编码的模块！我们在网上明文传送的时候，可以用它来简单的伪装： 123import base64msg=b&apos;Hi,I am 007&apos;print (&apos;raw msg:&apos;,msg) 输出:raw msg: b’Hi,I am 007’ 12decode_msg=base64.b64encode(msg)print (&apos;decode msg:&apos;,decode_msg) 输出:decode msg: b’SGksSSBhbSAwMDc=’ (这就算加密的信息) 12msg=base64.b64decode(decode_msg)print (&apos;restore msg:&apos;,msg) 输出：restore msg: b’Hi,I am 007’ base64两个内置函数就可以实现非常简单的加密和解密，传输在网上的就变成一段乱七八糟的文字 2.深入加密，hashlib很多服务器上都有hashlib进行加密，好处就算这样的加密会用”加盐”的操作，就算加入一个混淆的字符串然后进行hash. 这里的salt就算加盐 1234567891011import hashlibpasswd=&apos;123456&apos;salt=&apos;aaa&apos;new_passwd=passwd+saltdecode_passwd=hashlib.md5(new_passwd.encode(&apos;utf-8&apos;)).hexdigest()print(decode_passwd)//**服务器上存储的一个KEY,不能泄漏**API_KEY=&apos;93a9e5bb1d598a453606e890f72bd393&apos;assert decode_passwd==API_KEYprint (&apos;ok&apos;) 这样的加密，其实很多交易所都是这样的加密方法 3.神级加密如果上面的几种加密还是不放心，Python里面可以用几十行代码搞定的神级加密！需要安装一个第三方库pycrypto,这个库非常牛，里面的加密方式非常多，我这里取最简单的一种AES（高标准加密)12345678910from Crypto.Cipher import AES//**密钥,长度必须为16**secret_key = &apos;a&apos;*16//**IV参数，长度必须为16，一个初始化的矢量**iv_param = &apos;b&apos;*16//**要加密的明文密码，长度必须是16的倍数，不足就补齐16位**passwd = &quot;1234567890123456&quot;print (&apos;Your passwd:&apos;,passwd) 输出:Your passwd: 1234567890123456 数据加密123aes = AES.new(secret_key, AES.MODE_CBC, iv_param)encrypt_data = aes.encrypt(passwd)print(&apos;encrypt data：&apos;, encrypt_data) 输出：encrypt data： b’\xa9Q\x9a\xcf\x1b\x86\x10z\x93\x00\x12\x02;\xef\xd6\x14’ 数据解密123aes= AES.new(secret_key, AES.MODE_CBC, iv_param)decrypt_data = aes.decrypt(encrypt_data)print(&apos;plain text：&apos;, decrypt_data) 输出：plain text： b’1234567890123456’ 这个加密非常安全，128个比特，而且有双重的密钥匙，你想破解非常麻烦，只有接收方知道这双重密钥才能破解！]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium 学习_1]]></title>
    <url>%2F2018%2F05%2F09%2FPython%2F2018-05-09%2F</url>
    <content type="text"><![CDATA[虽然环境的安装比较麻烦，但我决定还是不要继续这个网上一搜就能搜到一大片文章的问题来浪费时间。第一篇主要就第一个例子-通过 appium 连接 android 安装一个 apk 来讲解。 Mac/Linux终端命令首先是放上一些 可能会用到的命令。事实上，我是几乎全用到了的。 adb 工具使用这个命令可以针对比较老的 appium，因为老版本的 appium 是需要在 capabilities 中指定 包名（appPackage）和启动页的（appActivity）这两个参数的。新版本的 appium（主要针对1.7.2及之后版本）会自动识别。只需要指定平台、设备名、app 路径三个参数就行。 12adb devices #获取连接主机的设备名aapt dump badging xxx.apk #获取测试包的信息 终端查看进程123ps aux | lesslsof -i tcp:8080 #查看8080 端口被什么进程占了kill -9 PIDNUM #关闭 PIDNUM 的进程 步骤编写动作脚本新建一个 AppiumPython 目录，在里面新建 case文件夹，在 case 文件夹下创建 start_appium.py 脚本文件。在 start_appium 中编写 capabilities 1234567891011#coding=utf-8from appium import webdrivercapabilities = &#123; &quot;platformName&quot;: &quot;Android&quot;, &quot;deviceName&quot;:&quot;127.0.0.1:21503&quot;,# 设备名随意 &quot;app&quot;:&quot;/Users/usr/Desktop/xxx.apk&quot; #app 路径&#125;webdriver.Remote(&quot;http://127.0.0.1:4723/wd/hub&quot;,capabilities) #IP地址和端口号需要与之后启动的 appium 中设定的地址和端口号一致 连接 android 设备连接实体机或者开启模拟器。通过 adb devices 来查看是否已经成功连接。 终端启动 appium直接在终端输入 appium 回车就可以了出现 Welcome to Appium v1.8.1 就表示成功启动了 1234MacBook-Pro:~% appium(node:20711) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.[Appium] Welcome to Appium v1.8.1[Appium] Appium REST http interface listener started on 0.0.0.0:4723 0.0.0.0 地址就是本地地址。 运行 脚本命令可以在 启动 appium 的终端窗口看到脚本运行情况。 遇到的问题在脚本中使用 get_window_size 方法。运行后就会跳异常： 1Message: The URL &apos;/wd/hub/session/799ef0f9-0735-41a3-bce9-ff017f27f3ff/window/size&apos; did not map to a valid resource 解决： 安装的appium-python-clicent 库里的 webdriver.py 没有get_window_size 这个方法。然后今天在 selenium 库下的 remote目录下的 webdriver.py 文件里发现了 get_window_rect 方法。我把代码里的 get_window_size 方法用 rect 方法替换，然后成功获取到了手机的屏幕大小； 过程：想群友拿了份老的 appium 库下的原因：]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>移动自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 print篇]]></title>
    <url>%2F2018%2F04%2F16%2FPython%2F2018-04-16%2F</url>
    <content type="text"><![CDATA[print函数原型1print(*objects, sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout, flush=False) 默认情况下，分隔符为空格sep=’ ‘，行结尾符为换行符end=’\n’，输出到标准输出file=sys.stdout，而且为带缓冲的flush=False。 print函数自定义分隔符或行尾结束符多数时候，不想要每次打印时行尾的换行符，设置end=’’即可，例如： 123456789101112&gt;&gt;&gt; for i in range(5):... print(i)... 01234&gt;&gt;&gt; for i in range(5):... print(i, end=&apos;&apos;)... &gt;&gt;&gt;01234 如果不知道print函数的sep关键字参数，很可能会写出如下丑陋的代码：123print(a + &apos;:&apos; + b + &apos;:&apos; + c) # Uglyprint(&apos;:&apos;.join([a, b, c])) # Still uglyprint(a, b, c, sep=&apos;:&apos;) # Better print函数打印输出到文件设置file关键字参数为带有write(string)方法的对象即可，例如： 12with open(&apos;somefile.txt&apos;, &apos;wt&apos;) as f: print(&apos;hello world!&apos;, file=f) 确保文件是以文本模式wt打开的，如果文件是二进制模式打开的话，打印就会失败 设置flush=True即可不带缓冲的打印输出文本。1print(&apos;some text&apos;, flush=True) 转载地址: 『Python3 print函数的四个关键字参数』：http://www.revotu.com/python3-print-function-keyword-arguments.html]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫代理篇]]></title>
    <url>%2F2018%2F03%2F02%2FPython%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[一、为何要设置User Agent 有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。 User Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。 Python允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。 二、常见的User Agent 1.AndroidMozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 2.FirefoxMozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0 3.Google ChromeMozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19 4.iOSMozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3 上面列举了Andriod、Firefox、Google Chrome、iOS的一些User Agent，直接copy就能用。]]></content>
      <categories>
        <category>python 爬虫</category>
      </categories>
      <tags>
        <tag>User Agent</tag>
        <tag>IP 代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 项目4 文章评论功能]]></title>
    <url>%2F2018%2F02%2F28%2FPython%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[主要是为熟悉，使用 Post 方法增加文章详情页评论功能。 本文django 表单创建流程： 准备工作 创建渲染表单 数据校验 数据存储 定制化表单 评论页面准备工作：django 自带表单系统处理步骤： 渲染表单 绑定表单 返回校验结果 此处新建了一个文章详情页来创建表单功能，表单内容为评论部分；因此此处新添加了数据模型，重新分配了 url。 在 model 添加评论模型123456class comment(models.Model): name = models.CharField(null=True, blank=True, max_length=50) comment = models.TextField() def __str__(self): return self.comment 然后再终端中进行数据合并，执行命令： 12345678910% python3 manage.py makemigrationsMigrations for &apos;django_demo&apos;: django_demo/migrations/0006_auto_20180228_0754.py - Create model comment - Alter field tag on article% python3 manage.py migrateOperations to perform: Apply all migrations: admin, auth, contenttypes, django_demo, sessionsRunning migrations: Applying django_demo.0006_auto_20180228_0754... OK view 添加逻辑12345def detail(request): context = &#123;&#125; comment_list = Comment.objects.all() context[&apos;comment_list&apos;] = comment_list return render(request, &apos;detail.html&apos;, context) url 分配url在 url 中 引入view内的 detail 1from django_demo.views import first_try, index, detail 在 urlpatterns 中添加 url 1path(r&apos;detail/&apos;, detail, name=&apos;detail&apos;), 渲染表单创建表单表单在 views.py 中创建。创建的方式与数据模型的创建非常相似。 引入 forms 创建表单函数 12345from django import formsclass CommentForm(forms.Form): name = forms.CharField(max_length=50) comment = forms.CharField() 实例化 表单，并带入数据模型当中。在 detail 数据模型类中 定义表单对象，并添加到内容中。 1234567def detail(request): form = CommentForm context = &#123;&#125; comment_list = Comment.objects.all() context[&apos;comment_list&apos;] = comment_list context[&apos;form&apos;] = form return render(request, &apos;detail.html&apos;, context) 模板层渲染 绑定表单 &amp; 返回校验结果在 views.py 中的 detail 数据模型下 修改代码如下： 12345678910111213def detail(request): if request.method == &apos;GET&apos;: form = CommentForm if request.method == &apos;POST&apos;: #绑定表单， 是进行数据校验的前置步骤 form = CommentForm(request.POST) print(form) print(form.errors) context = &#123;&#125; comment_list = Comment.objects.all() context[&apos;comment_list&apos;] = comment_list context[&apos;form&apos;] = form return render(request, &apos;detail.html&apos;, context) 一般在绑定表单后，就会触发数据验证，若有错误会将错误信息填写入 errorlist 中，可以通过print(form.errors) 来打印出。 表单数据存储需要 导入redirect， 1from django.shortcuts import render, redirect 然后在 detail 数据模型中添加代码 1234567891011121314151617181920def detail(request): if request.method == &apos;GET&apos;: form = CommentForm if request.method == &apos;POST&apos;: # 绑定表单， 是进行数据校验的前置步骤 form = CommentForm(request.POST) # 判断绑定的表单是否通过数据验证 if form.is_valid(): # 表单数据通过后，会将数据存储在 cleaned_data 中 name = form.cleaned_data[&apos;name&apos;] comment = form.cleaned_data[&apos;comment&apos;] c = Comment(name=name, comment=comment) c.save() # redirect 重定向回 name=detail 的 url return redirect(to=&apos;detail&apos;) context = &#123;&#125; comment_list = Comment.objects.all() context[&apos;comment_list&apos;] = comment_list context[&apos;form&apos;] = form return render(request, &apos;detail.html&apos;, context) 当 校验信息返回 false 时，会直接将错误信息装填在绑定表单时生成的错误列表中，然后装填在form 中，进行错误信息的渲染。所以不需要进行 else 的逻辑判断。 ps. form.is_valid() 以及 form = CommentForm(request.POST) 都会触发数据验证 这一步完成后，就能在 detail 页面进行评论了。 定制化表单 添加更加详细的验证 修改前段的表现形式 定制化表单的验证逻辑首先我们需要把 views.py 文件中的 CommentForm 类解耦到 form.py 文件中。 新建 form.py 文件 123456from django import formsclass CommentForm(forms.Form): comment = forms.CharField() name = forms.CharField(max_length=50) 接下来在该文件中，添加表单的逻辑。 自带的数据校验：12345678class CommentForm(forms.Form): name = forms.CharField(max_length=50) comment = forms.CharField( widget=forms.Textarea(), error_messages=&#123; &apos;required&apos;: &apos;input your comment, please&apos; &#125; ) 在需要添加校验的字段后添加参数 error_message， 复写错误提示语；一般提示语有三类required，invalid，max_length以字典形式写入。 这个自带的数据校验器，我并没有生效。 数据验证器在 form.py 中引入 from django.core.exceptions import ValidationError 然后定义数据验证逻辑，在 error_messages 中写入 validators 列表中 123456789101112131415161718192021def words_validator(comment): if len(comment) &lt; 4: raise ValidationError(&apos;Not enough words&apos;)def comment_validator(comment): if &apos;a&apos; in comment: raise ValidationError(&apos;&quot;a&quot; is must not&apos;)class CommentForm(forms.Form): name = forms.CharField(max_length=50) comment = forms.CharField( widget=forms.Textarea(), error_messages=&#123; &apos;required&apos;: &apos;input your comment, please&apos;, &apos;invalid&apos;: &apos;invalid&apos;, &apos;max_length&apos;: &apos;too much&apos; &#125;, validators=[words_validator, comment_validator] ) 验证器不仅能在表单的数据校验中使用，也可以在数据模型中使用。 定制表单的手工渲染对报错信息进行单独的手工渲染。 现在的报错样式： 手工渲染表单删除原先的 form.as_p 123456789101112&lt;form class=&quot;ui tiny form&quot; method=&quot;post&quot;&gt; &#123;% for field in form %&#125; &lt;div class=&quot;field&quot;&gt; &#123;&#123; field.label &#125;&#125; &#123;&#123; field &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% csrf_token %&#125; &lt;button type=&quot;submit&quot; class=&quot;ui blue button&quot; &gt;Click&lt;/button&gt; &lt;/form&gt; 返回网页端，进行测试，发现评论内容无法进行数据验证。 渲染报错信息 1234567891011121314151617181920212223242526272829 &#123;# semantic error form 布局#&#125; &lt;form class=&quot;ui error tiny form&quot; method=&quot;post&quot;&gt;&#123;# 判断是否存在 error 信息#&#125; &#123;% if form.errors %&#125; &lt;div class=&quot;ui error message&quot;&gt; &#123;&#123; form.errors &#125;&#125; &lt;/div&gt; &#123;% for field in form %&#125;&#123;# 遍历表单字段，不通过数据校验的字段渲染成出错样式 并给出提示#&#125; &lt;div class=&quot;&#123;&#123; field.errors|yesno:&apos;error,&apos; &#125;&#125; field&quot;&gt; &#123;&#123; field.label &#125;&#125; &#123;&#123; field &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% else %&#125; &#123;% for field in form %&#125; &lt;div class=&quot;field&quot;&gt; &#123;&#123; field.label &#125;&#125; &#123;&#123; field &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &#123;% csrf_token %&#125; &lt;button type=&quot;submit&quot; class=&quot;ui blue button&quot;&gt;Click&lt;/button&gt; &lt;/form&gt; 源码地址: 『NiuCodeLesson/DjangoWeb/DjangoWebFirst/』:https://github.com/wengfe/NiuCodeLesson/tree/master/DjangoWeb/DjangoWebFirst]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 项目3 文章分类功能]]></title>
    <url>%2F2018%2F02%2F28%2FPython%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[主要是为熟悉，使用 get 方法获取分类文章。 在 model 层增加 tag 字段。 在 view 层编写逻辑，根据请求返回结果。 template 与用户交互 Time Will Tell Time: T template 网页展示给用户 M model 是数据 Will： V view 视图层 U url 链接视图的urlTell: T template 喜欢，处理视图 model 层添加 Tag 字段12345678910class Article(models.Model): headline = models.CharField(null=True, blank=True, max_length=500) content = models.TextField(null=True, blank=True) TAG_CHOICES = &#123; (&apos;teach&apos;, &apos;Teach&apos;), (&apos;life&apos;, &apos;Life&apos;) &#125; # choices 参数： 提供一组下拉菜单选项 tag = models.TextField(null=True, blank=True, max_length=5, choices=TAG_CHOICES) 重新定义数据库中 Article 类在终端中执行命令 python3 manage.py makemigrations python3 manage.py migrate这两条命令，下面示意图是因为我已经合并过了。 正确的提示跟 web 框架下的 Django 框架下，新建，合并数据库的提示类似。在定义好新的 article tag 字段后，需要在 网页代码中修改为文章的标签 123&lt;div class=&quot;ui mini tag label&quot;&gt; &#123;&#123; article.tag &#125;&#125;&lt;/div&gt; views 中的逻辑12345678910111213print(request) print(&apos;===&apos; * 30) print(dir(request)) print(&apos;===&apos; * 30) print(type(request)) queruseet = request.GET.get(&apos;tag&apos;) print(queruseet) if queruseet: article_list = Article.objects.filter(tag=queruseet) else: # 数据库操作方法，从指定表中取得所有值 table_mame.objects.all() article_list = Article.objects.all() 在 views.py 文件 index 函数下的上次代码基础上添加上述 if/else 代码，做逻辑处理。若是请求中存在标签，就将存有该表的文章添加到文章列表，予以展示，否则展示全部文章。 Template 中的交互在 html 中 categories 标签分类下设置 href 链接 这样点击 categories 中的标签，就能在 url 后添加参数。]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 项目2 创建笔记]]></title>
    <url>%2F2018%2F02%2F27%2FPython%2F2018-02-27%2F</url>
    <content type="text"><![CDATA[创建模板从 Django 项目1 文章的结尾处开始。首先需要贮备好静态网页。将静态网页的 html 文件放入项目目录下的 template 文件夹下，网页的其他静态文件放入项目下新建的 static 文件夹下。 ps.部分代码因为与 hexo 语法冲突，无法渲染，采用图片形式。 使用静态文件标签更新 html 内的静态资源路径。在 html 标签的上一行 添加 staticfiles 123&#123;% staticfiles %&#125;&lt;html&gt;... 静态文件标签会加载所有的静态文件。模板语言分三部分： 模板标签 123 &#123;% %&#125; ``` 2. 模板变量 12345678910111213143. 模板过滤器 &lt;img src=&quot;https://lh3.googleusercontent.com/-dlMKuY1RJss/WpZVMW75ngI/AAAAAAAAAJY/RzW0L694B-g0ZneUIkSo4Bkf6A7EKyd8QCHMYCw/I/15198016478635.png&quot; width = &quot;400&quot; alt=&quot;template_filter&quot;/&gt;## 创建后台Django 自带一个可视化后台，方便用户管理数据。### 登录后台启动我们的项目，在端口号后填入 `/admin`可以看到，一个后台登录页面。因为没有超级管理员所以登录不了。#### 创建超级管理员在终端中输入 `python3 manage.py createsuperuser` 创建超级管理员。 Username (leave blank to use ‘fuyiweng’): adminEmail address:Password:Password (again):Superuser created successfully.123456789101112email 可以不填。密码输入不可见。回到后台页面，使用刚刚创建的超级管理员登录。![](https://lh3.googleusercontent.com/-6JESCuvzIss/WoKYRqt4rVI/AAAAAAAAAHg/c87qxEawttsZZqhGVzTO7lhk1oXv4rPhQCHMYCw/I/15185080999231.png)可以看到有两张表，但是没有上一篇文章中的 People 表。### 关联自定义表回到 IDE ，admin.py 就是我们后台管理数据库的文件，需要向这个文件中注册我们创建的表。在文件中添加： from django_demo.models import People admin.site.register(People)1234刷新网页，出现 People 表，通过网页在表中添加一个对象，存储后显示为一个 People object 。但并不方便我们通过这个管理后台。返回 models 文件的 People 类下，增加 `__str__` 函数，返回对象 name def __str__(self): return self.name 1234567891011121314刷新网页，People 表下的对象显示为对象名。#### 新增 Article 表重新温习一下，添加表流程1. 在 models 文件下新增 Aritcle 类2. 在 admin 文件下 引入 Aritcle 类， 并 regist3. 在终端执行 `python3 manage.py makemigrations `4. 在终端执行 `python3 manage.py migrate`## model 引入数据在 views 中新建一个函数，作为主页。正确的引用数据的方法是创建一个实例，将所有数据装载在变量中。 def index(request): context = {} # 数据库操作方法，从指定表中取得所有值 table_mame.objects.all() article_list = Aritcle.objects.all() # 往字典中填入数据 context[&apos;article_list&apos;] = article_list index_page = render(request, &apos;first_web_2.html&apos;, context) return index_page 123## 模板语言遍历模板 ``` 在模板中调整路径]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 中的 render 函数]]></title>
    <url>%2F2018%2F02%2F13%2FPython%2F2018-02-13%2F</url>
    <content type="text"><![CDATA[render 函数渲染函数，接收三个参数 render(request, x.html, context)x.html ： 模板名称context： 上下文 之前我一直认为，上下文是比较难以理解的概念，最近找到一个比较容易理解的方法。 There’s a block waiting in the sky.加粗字体换成 Taxi Pie 可以形成不同的句意。 Django 中的上下文就相当于是数据库中取得的数据与网页显示部分的映射]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>render</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的 web 常见框架(Django 项目1)]]></title>
    <url>%2F2018%2F02%2F11%2FPython%2F2018-02-11%2F</url>
    <content type="text"><![CDATA[大包大揽 Django 力求精简 web.py 和 Tornabo 新生代微框架 Flask 和 Bottle 微框架优势： 聚焦业务逻辑 学习成本低 灵活性和伸缩性较强 劣势： 很多逻辑需要手动编写 安装大量模块后体积较大 Flask保持核心简单，易扩展。不包括数据库抽象层，表单验证等。 可通过添加扩展的方式添加功能 安装1pip install flask 通过导入 flask 模块，来验证安装是否成功。 表单开发表单标签用于声明表单范围，位于表单标签中的元素将被提交语法： `属性： method， Enctype， action 表单域表单域包含文本框，密码框等多种类型语法： &lt;input.../&gt;属性： type，name，value 表单域种类文本框： &lt;…type:text&gt;密码框：&lt;…type:password&gt;文本区域：&lt;…type:textarea&gt;文件上传框：&lt;…type:file&gt;单选框：&lt;…type:radio&gt;复选框：&lt;…type:checkbox&gt; 复选框的值为数组形式。 表单按钮提交按钮复位按钮一般按钮 表单提交方式GETPOST 数据放置在 HTML Header 中提交。 GET 可以被浏览器缓存 数据暴露 URL适合：单纯请求数据，不进行其他操作 表单数据较短，不超过 1024 字符 对安全性要求一般 POST URL 可以被缓存，数据不被缓存 请求不便分享，没有长度限制适合：不仅仅用于请求，需要将数据插入数据库内 表单数据过长 传送的数据不是 ASCII 编码 Djongo优势： 详细的文档 全套结局啊方案 强大的 URL 路由配置 完善的自主管理后台 劣势： 紧耦合 自带 ORM 不够强大 Template 较弱 MTV 模型工作模型： 创建虚拟环境 virtualenv如果你生产或开发环境需同时支持 Python 2 和 Python 3 ，那就需要 virtualenv。我们是从零开始学习 Django，所以可以直接使用 venv。简单来说，venv 模块是 Python 3.3 版本之后，标准库自带的虚拟环境创建和管理工具，在 Python 3 版本是代替 virtualenv。 使用 venv 在当前系统中创建出一个环境，该环境可以跟当前系统互不影响，你可以随意折腾。出现问题，只要删除即可，不会影响到当前系统。另外，有了 virtualenv 虚拟环境之后，我们就可以把那个文件夹整体拷贝了，部署起来方便很多。 步骤：一. 创建项目目录创建项目主目录。并进入主目录，创建项目目录 123mkdir DjangoWebcd DjangoWebmkdir DjangoWebFirst 二. 创建虚拟环境，激活虚拟环境--no-site-packages 表示不安装系统中的第三库创建虚拟环境。 1virtualenv --no-site-packages env_python 三. 使用 pycharm 创建项目 在 location 填入项目目录所在路径在 Interpreter 填入新建的虚拟环境在 Application 填入第一个网站的名字 创建好后，目录类似这样： 创建数据库 12345678910111213141516171819202122python3 manage.py migrateOperations to perform: Apply all migrations: admin, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying sessions.0001_initial... OK(env_python) fuyiweng@fuyiwengdeMacBook-Pro:~/Documents/study/NiuCodeLesson/DjangoWeb/DjangoWebFirst% python3 manage.py makemigrationsMigrations for &apos;django_demo&apos;: django_demo/migrations/0001_initial.py - Create model People 新建数据库： 在 models.py 中新建一个 People 类， 在终端执行：python3 manage.py makemigrations 创建建表策略 执行表合并： 123456789NiuCodeLesson/DjangoWeb/DjangoWebFirst% python3 manage.py migrateOperations to perform: Apply all migrations: admin, auth, contenttypes, django_demo, sessionsRunning migrations: Applying django_demo.0001_initial... OK``` 在 views 中创建页面：在 views 文件中，新建 first_try 类： from django.shortcuts import renderfrom django.http import HttpRequest, HttpResponsefrom django_demo.models import Peoplefrom django.template import Context, Template Create your views here.def first_try(request): person = People(name=’jack’, job=’officer’) html_string = ‘’’ diango Hello, ‘’’ # 将 html 字符转成模板 t = Template(html_string) # 组上下文 c = Context({&apos;person&apos;: person}) # 渲染模板 web_page = t.render(c) return HttpResponse(web_page) ``` 在 urls 中增加 first_try 的 url： 引入 first_try from django_demo.views import first_try 增加路径 urlpatterns 下添加 path(r&#39;first_try/&#39;, first_try), 完成。]]></content>
      <categories>
        <category>python</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL 查询优化]]></title>
    <url>%2F2018%2F02%2F08%2FPython%2F2018-02-08%2F</url>
    <content type="text"><![CDATA[本文主要目的就是对数据库的优化查询，但查询过程中碰到了一个不明缘由的问题，希望有大神能够帮忙解释一波。 目的从 csv 文件中随机选取 100 条 Ip 地址，并在表中查询这 100条 ip 的所在地。 步骤 读取样本，组装列表 表建立索引 优化 sql 语法 联合查询 读取文件读取文件和上一篇文章所讲的一样，利用 with 语法避免文件句柄关闭操作，给 open 函数增加 encoding 参数。 然后将读取的数据进行拆分和整理： 123456789with open(&apos;./ipdata.csv&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: lines = f.readlines()nl_p_list = []for l in lines: ls = l.strip().split(&apos;,&apos;, 4) c1, c2, c3, c4, c5 = ls[0], ip2int(ls[1]), ip2int(ls[2]), ls[3], ls[4] nl = [c1, c2, c3, c4, c5] nl_p_list.append(nl) 表建立索引使用 navicat 连接表，进入 「设计表」 模块，为 startip 和 endip 建立索引。 优化 sql 语法如果使用复杂语法的 sql 语句，是无法利用索引大幅提升查询效率的，比如通过 between and 查询： SELECT * FROM ipdata WHERE IpNum BETWEEN startip AND endip 因为 ip 是连续的，所以只要这个 Ip 地址大于或等于某一个号段的起始地址，那么依照降序排序第一的 ip 段的所在地，就是被查询的 ip 地址的所在地。 SELECT * FROM ipdata WHERE IpNum &gt;= startip ORDER BY startip DESC LIMIT 1 经过对比发现，查询速度果然是有质的飞跃。但也出现了问题。问题详情我会在文末写明。 联合查询利用索引的 sql 语句果然是如有神助，在我的运行环境里， between and 查询语句，查询 100 条记录需要 32s+ ，但在优化后能提升到 0.7s 左右。 但是在使用联合查询后，还能提升将近 2 倍的速率。 联合查询的 sql 语法： 123SELECT t1.* FROM (SELECT * FROM ipdata WHERE 1780997668 &gt;= startip ORDER BY startip DESC LIMIT 1) t1UNION ALLSELECT t2.* FROM (SELECT * FROM ipdata WHERE 3425736747 &gt;= startip ORDER BY startip DESC LIMIT 1) t2; 下一步，就是加工 sql 联合语句了。联合查询的 sql 语句，不宜过长，比较适合的长度就是 100 条。 1234sql_str = &apos;SELECT &#123;0&#125;.* FROM (SELECT * FROM ipdata WHERE %s &gt;= startip ORDER BY startip DESC LIMIT 1) &#123;0&#125;&apos;for i in range(len(ip_list)): sql_list.append(sql_str.format(&apos;t&apos; + str(i)) % ip_list[i])sql = &apos; union all &apos;.join(sql_list) 使用 format 函数填充别名， %s 填充 IP 地址 。最后执行 sql 语句： 1cursor.execute(sql) 效果也是有的，将查询的速度提升到了 0.3s 左右。 至此， sql 的数据表查询优化部分那就结束了。 遇到的灵异现象如图所示，我注释了 t1, t2, t3, t4 之间的代码。 时间段 含义 运行速度 t0 ~ t1 联合优化 sql 语句查询 0.0318 t1 ~ t2 优化 sql 语句查询 9.5367 t3 ~ t2 between and 语句查询 1.1920 t4 ~ t3 联合 between and 语句查询 0.0 事实上，除了 t0 ~ t1 之间的时间是大致在 0.03s ~ 0.07s 波动，剩余的三个时间段的代码已经被我注释，理论上应该是不耗费时间的，但会随机在剩余的三个时间段 打印出 9s 左右的耗时。希望有大神能够帮助一波。 源码地址: 『NiuCodeLesson/insertSQL/』：https://github.com/wengfe/NiuCodeLesson/tree/master/insertSQL]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL 批量插入操作]]></title>
    <url>%2F2018%2F02%2F07%2FPython%2F2018-02-07%2F</url>
    <content type="text"><![CDATA[对数据库的增删改查平时的工作中用的比较多，也比较熟悉。忽然发现都没有使用过 insert 操作，因此在学习 python 的过程中，通过 mysql.connector 对 44w行 的 ip地址记录进行数据库批量插入工作。 步骤分为以下五步： 1. 数据格式整理 2. 创建表 3. 连接表 4. 读取本地文件数据 5. 批量写入 数据格式整理首先查看所拿到的数据，并整理：分别在终端中使用 head ipdata.csv 和 tail ipdata.csv 来查看文件的头部和尾部数据，对其规律进行分析。 12345678910111213141516171819202122:~/Documents/study/NiuCodeLesson/insertSQL% head ipdata.csv1,0.0.0.0,0.255.255.255,IANA,保留地址2,1.0.0.0,1.0.0.255,澳大利亚,CZ88.NET3,1.0.1.0,1.0.3.255,福建省,电信4,1.0.4.0,1.0.7.255,澳大利亚,CZ88.NET5,1.0.8.0,1.0.15.255,广东省,电信6,1.0.16.0,1.0.31.255,日本,Beacon服务器7,1.0.32.0,1.0.63.255,广东省,电信8,1.0.64.0,1.0.127.255,日本,広島県中区大手町Energia通信公司9,1.0.128.0,1.0.255.255,泰国,CZ88.NET10,1.1.0.0,1.1.0.255,福建省,电信:~/Documents/study/NiuCodeLesson/insertSQL% tail ipdata.csv444954,223.255.252.0,223.255.253.255,福建省,电信444955,223.255.254.0,223.255.254.255,新加坡,滨海湾金沙私人有限公司444956,223.255.255.0,223.255.255.255,澳大利亚,CZ88.NET444957,224.0.0.0,224.255.255.255,IANA,CZ88.NET444958,225.0.0.0,239.255.255.255,IANA保留地址,用于多点传送444959,240.0.0.0,247.255.255.255,IANA保留地址,CZ88.NET444960,248.0.0.0,248.255.255.255,IANA保留地址,CZ88.NET444961,249.0.0.0,254.255.255.255,IANA保留地址,CZ88.NET444962,255.0.0.0,255.255.254.255,CZ88.NET,444963,255.255.255.0,255.255.255.255,纯真网络,2014年10月25日IP数据 查看后我们可以大致将数据分为 5 列，「序号」，「起始IP」，「终止IP」，「所在地」，「运营商」。 创建表经过格式的分析，我们就可以创建一个表的结构了。注：事实上分析数据规律比建表要重要的多，因为本文重点不在此处，所以概过。 首先通过 navicat 创建本地的数据库。数据库格式如下图： 连接表首先连接本地数据库因为我的表示创建在本地数据库下的，连接的库的时候不需要添加 host 参数连接本地数据库的代码如下： 1conn = mysql.connector.connect(user=&apos;root&apos;, password=&apos;admin&apos;, database=&apos;test&apos;) 连接远程数据库的代码如下： 1conn = connection.MySQLConnection(host=host_d, user=user_d, password=password_d, database=database_d) 读取 csv 数据文件一般来说，读取文件的方法有两种；推荐以下方式来读取文件，可以避免忘记关闭文件句柄的尴尬： 12with open(&apos;./ipdata.csv&apos;, &apos;r&apos;) as f: lines = f.readlines() 读取文件格式采坑在读取文件的过程中发现了报错。 报错信息：1UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 29: ordinal not in range(128) 原因分析：出错的原因是因为 csv 内的编码方式与程序环境编码方式不一致所致。csv 的编码格式是 gbk， 只要能够用 unicode 编码格式处理读取进来的数据就解决了。 搜索解决方案：自从上次瞎捷豹连续操劳后，已经很久没有让它出门了，这次又要有劳它了。经过搜索后，发现很多方案： 方案一 代码头部申明编码有两种写法，然而在试验后，表示并没有解决问题ㄟ( ▔, ▔ )ㄏ。 1# -*- coding: utf-8 -*- 1# coding = utf-8 方案二 IDE 设置编码格式虽然在 「偏好设置 - Editor - File Encodings」 内全都设置（默认设置）了 UTF-8，但是在读入数据文件 ipdata.csv 的时候，还是出现了错误。我也很奇怪为什么没有生效。 方案三 修改默认 encoding 格式 在代码头部导入 sys 库； 重载 sys 库，网上说 Python 文件运行后，会删除 setdefaultencoding 方法？ 设置默认 encoding 格式。 123import sysreload(sys) sys.setdefaultencoding(&apos;utf-8&apos;) 运行后显示找不到 setdefaultending 方法. 瞎捷豹愤而暴走，告诉我因为在 py3 中默认的编码格式为 unicode 解码？所以取消了 setdefaultending 方法。 正解：引入 codecs 库codecs 库中的 open 方法可以添加 encoding 参数，完美解决。 1234import codecswith open(&apos;./ipdata.csv&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: lines = f.readlines() 后来发现其实 3.6 版本的 py 早就集成了 open 函数的 encoding 参数。所以并不用导入 codecs 库。 批量写入插入操作的 sql 写法为 : 1insert into tablename (key1, key2, key3...) values (value1, value2, value3...) 使用 cursor.executemany() 方法来执行批量插入操作 方法为： 12cursor = conn.cursor()ret = cursor.executemany(&apos;insert into ipdata (id, startip, endip, country, carrier) values (%s, %s, %s, %s, %s)&apos;, nl_p_list) 失去连接报错12055: Lost connection to MySQL server at &apos;127.0.0.1:3306&apos;, system error: 32 Broken pipe 猜测是数据量太大所致，所以对读入的文件进行切片，分批插入表中； 12345for i in range(int(len(nl_p_list)/1000 +1)): tmp_nl_p_list = nl_p_list[i*1000: (i+1)*1000] # 批量插入表中 ret = cursor.executemany(&apos;insert into ipdata (id, startip, endip, country, carrier) values (%s, %s, %s, %s, %s)&apos;, tmp_nl_p_list) 数据库插入中文错误出现了新的报错，查看报错信息： 11366 (HY000): Incorrect string value: &apos;\xE4\xBF\x9D\xE7\x95\x99...&apos; for column &apos;carrier&apos; at row 1 对报错信息显示 异常的 string 值，截取报错信息交给瞎捷豹，很快找到了解决方案；还是编码格式锅，不过这次是表结构编码格式不符。 在 navicat 表设计 - DDL 中查看 ipdata 的表结构： 12345678CREATE TABLE `ipdata` ( `id` int(11) NOT NULL, `startip` bigint(20) DEFAULT NULL, `endip` bigint(20) DEFAULT NULL, `country` text, `carrier` text, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1; 发现表编码为 latin1 。 果然不是 utf-8。通过 navicat 查询功能修改表编码格式，输入代码并执行： 1alter table ipdata convert to character set utf8; 重新查看表结构： 12345678CREATE TABLE `ipdata` ( `id` int(11) NOT NULL, `startip` bigint(20) DEFAULT NULL, `endip` bigint(20) DEFAULT NULL, `country` text, `carrier` text, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 重新运行代码，数据成功写入表中。 使用 navicat 的查询功能： select count(*) from ipdata 得到记录行数 444963，写入记录正常。 计划通！ 参考链接： 『mysql.connector 批量插入』：https://my.oschina.net/hhdys412/blog/182762 源码地址: 『NiuCodeLesson/insertSQL/』：https://github.com/wengfe/NiuCodeLesson/tree/master/insertSQL]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy-ORM]]></title>
    <url>%2F2018%2F02%2F06%2FPython%2F2018-02-06%2F</url>
    <content type="text"><![CDATA[上一篇所用的代码，是廖雪峰大大 python 数据库章节中的 SQLAlchemy 中的部分。因为踩到不少坑，所以又找到相关的资料进行学习。这一片主要将 sqlalchemy-orm 部分进行总结。ORM（Object Relational Mapper）可以理解为「将数据库中的表映射为程序中的类」。表中的一行即为该类的一个实例。 在使用 sqlalchemy 之前，需要先导入相关的库，在导入之前当然也是需要先安装。因为在代码中写入了大量的注释，所以就多 BB 了，文末会贴上本文代码的 github 的项目地址。在终端输入： 1pip install sqlalchemy 打开 pycharm 新建一个项目，然后导入以下库： 12345import sqlalchemyfrom sqlalchemy import create_engine, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, String, Integerfrom sqlalchemy.orm import sessionmaker 注：第二行的最后一个库是之后双表建立外键的时候需要添加的库 创建「表-类」映射创建表123456789101112131415161718192021222324# 利用数据库字符串构造engine, echo为True将打印所有的sql语句engine = create_engine(&apos;sqlite:///foo.db&apos;, echo=True)# 首先需要生成一个BaseModel类,作为所有模型类的基类Base = declarative_base()class User(Base): __tablename__ = &apos;user&apos; id = Column(Integer, primary_key=True) name = Column(String) fullname = Column(String) passward = Column(String) def __repr__(self): return &apos;&lt;User(name=&quot;%s&quot;, fullname=&quot;%s&quot;, passward=&quot;%s&quot;)&gt;&apos; % ( self.name, self.fullname, self.passward)# 创建所有表,如果表已经存在,则不会创建# Base.metadata.create_all(engine)# 删除所有表# Base.metadata.drop_all(engine) 创建表实例创建一个 User 实例， sqlalchemy ORM 通过 session（会话）来操作表，一个 session 实例可以添加多个事务，然后通过 commit 提交事务，未提交的表操作事务是不会反馈到表中。 123456789101112131415161718192021222324#创建一个 User 类实例ed_user = User(name=&apos;ed&apos;, fullname=&apos;Ed jones&apos;, passward=&apos;edspassward&apos;)# print(ed_user)# 利用Session对象连接数据库#创建会话类和会话类的对象Session = sessionmaker(bind=engine)session = Session()# 向事务会话中添加实例对象，向表中插入数据需要提交事务， 调用 commit() 方法# session.add(ed_user)##查询符合条件的第一条# our_user = session.query(User).filter_by(name=&apos;ed&apos;).first()# 相等于下方的 sql 语句# select * from User where name=&apos;ed&apos; limit 1;## session.add_all([# User(name=&apos;wendy&apos;, fullname=&apos;Wendy Williams&apos;, passward=&apos;foobar&apos;),# User(name=&apos;wendy2&apos;, fullname=&apos;Wendy Williams&apos;, passward=&apos;foobar&apos;),# User(name=&apos;wendy3&apos;, fullname=&apos;Wendy Williams&apos;, passward=&apos;foobar&apos;)# ])# session.commit() 通过 session 事务进行查询操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#查询全部# print(session.query(User).all())#查询符合条件的第一条# our_user = session.query(User).filter_by(name=&apos;ed&apos;).first()#排序# for row in session.query(User).order_by(User.id):# print(row)# 查询 in 操作# for row in session.query(User).filter(User.name.in_([&apos;ed&apos;, &apos;wendy&apos;])):# print(row)# 查询 not in 操作# for row in session.query(User).filter(~User.name.in_([&apos;ed&apos;, &apos;wendy&apos;])):# print(row)# count 操作# print(session.query(User).filter(User.name ==&apos;ed&apos;).count())# and 和 or 操作, 需要导入模块# from sqlalchemy import and_, or_# for row in session.query(User).filter(and_(User.name == &apos;ed&apos;, User.fullname == &apos;Ed jones&apos;)):# print(row)# for row in session.query(User).filter(or_(User.name == &apos;ed&apos;, User.name ==&apos;wendy&apos;)):# print(row)# 创建外键from sqlalchemy import ForeignKeyfrom sqlalchemy.orm import relationship, backrefclass Address(Base): __tablename__ = &apos;addresses&apos; id = Column(Integer, primary_key=True) email_address = Column(String, nullable=False) user_id = Column(Integer, ForeignKey(&apos;user.id&apos;)) # 关联 User 表主键为外键，此处为 多对1 user_i = relationship(&quot;User&quot;, backref=backref(&apos;addresses&apos;, order_by=id)) def __repr__(self): return &quot;&lt;Address(email_address=&apos;%s&apos;)&gt;&quot; % self.email_address# Base.metadata.create_all(engine)# jack = User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, passward=&apos;giffs&apos;)# jack.addresses = [# Address(email_address=&apos;jack@google.com&apos;),# Address(email_address=&apos;j25@yahoo.com&apos;)]## session.add(jack)# session.commit()# 双表联合查询for u, a in session.query(User, Address).\ filter(User.id == Address.user_id).\ filter(Address.email_address == &apos;jack@google.com&apos;).\ all(): print(u, a) 表数据修改操作123456789101112# 表修改# 造数据he_user = User(id=15, name=&apos;he&apos;, fullname=&apos;He jones&apos;, passward=&apos;edspassward&apos;)# session.add(he_user)# session.commit()# 使用merge方法，如果指定的主键已存在，修改记录，不存在新增一条记录session.merge(he_user)session.commit()# 关闭 sessionsession.close() github 地址：NiuCodeLesson/SQLalchemytest/SQLAlchemy.py]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>SQLAlchemy</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy 预使用 -- 本地环境配置]]></title>
    <url>%2F2018%2F02%2F01%2FPython%2F2018-02-01%2F</url>
    <content type="text"><![CDATA[因为之前使用 Python 操作数据库表时，目的是为了辅助工作，所以是直接对公司测试服务器上的数据库进行操作的。这次因为在学习 ORM ，所以需要在本地创建数据库。踩了一堆的烂坑，不得不说，大学时候没有听一节课，付出的时间代价会更大，我花了一天的时间进行踩坑学习才补回。 SQLAlchemy 是 python 平台上较为成熟的 ORM 框架。ORM -&gt; 对象关系映射，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”抛开百度百科，就我的使用方向说，就是建立函数与数据库表之间的映射关系，所以需要映射的数据库表的是需要事先创建好的。我就是在这里踩了大坑。 安装本地 MySQL首先需要启动本地的 MySQLserver，我使用的是 Mac，前往官网下载，直接安装就好了。安装好后会给你一个随机密码。请记住这个密码。 当然忘记了问题也不大。 链接本地数据库这里问题就有点多了，当我安装好 MySQL 后，打开 Navicat 新建本地数据库链接的时候，跳出很多的小问题。 Can’t connect to remote MySQL server with error 61一只瞎捷豹乱搜，找到原因： Mac 下安装mysql，安装完成后是无用户无密码的状态，并且数据库只有 information_schema 也找到了解决之道: 为 root 账户新建密码。 鬼知道为什么无用户无密码状态，还给了我一个默认密码。按照随便找到的解决方法指导： [x] 关闭本地 MySQL 服务（在系统偏好设置的最下面一栏） [x] 进入 MySQL 文件目录下 [x] 启动超级账户 [x] 安全模式启动 MySQL [ ] 另起终端，使用 root 用户启动 MySQL:执行 mysql -u root [ ] 为root用户设置新的密码 UPDATE mysql.user SET Password=PASSWORD(&#39;password&#39;) WHERE User=&#39;root&#39;; [ ] 刷新，生效设置。FLUSH PRIVILEGES; 1234567/usr/local/mysql/binsudo suPassword:sh-3.2# ./mysqld_safe --skip-grant-tables &amp;[1] 33563sh-3.2# 2018-02-01T05:43:01.6NZ mysqld_safe Logging to &apos;/usr/local/mysql-5.7.21-macos10.13-x86_64/data/fuyiwengdeMacBook-Pro.local.err&apos;.2018-02-01T05:43:01.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.21-macos10.13-x86_64/data 嗯，没错，我卡在了第五步 T&gt;T。 终端启用 MySQL 命令经过了惨无人道的瞎捷豹二次搜索，又成功找到了答案。 首先查看是否已添加 MySQL 的 PATH 路径 echo $PATH 如果能找到 mysql 的 PATH 路径（这是不可能的），问题解决 找不到，添加 MySQL 的路径，PATH=&quot;$PATH&quot;:/usr/local/mysql/bin 查看是否添加成功 12$ which mysql/usr/local/mysql/bin/mysql 如上所示，就是添加成功，我们可以继续放回上一个问题继续操作了。注：添加的 MySQL 路径为临时路径，关闭此终端后，下次打开将不再能运行 Your password has expired. To log in you must change it using a client that supports expired passwords.whatFuc—-A?瞎捷豹有点累，所以这次凭着我的三级英语，解密了这英文。密码过期，需要改密码。所以我刚刚改的是一个加密码？/usr/local/mysql/bin/mysqladmin -u root -p password输入旧密码，新密码。 然后就碰上了交学费的问题。 1049 (42000): Unknown database ‘test’ 和 1146 (42S02): Table ‘test.user’ doesn’t exist在之前配置了 MySQL 路径的终端中 使用 mysql 命令，show databases 果然发现没有需要链接的表。 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 创建数据库和表吧，这里对自己的蠢不予置评。 Q^Q 我竟然还在这花了1个小时。 再次运行代码，皆大欢喜。 参考链接：终端数据库管理修改数据库密码]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>SQLAlchemy</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 xlrd,xlwt 操作 excel]]></title>
    <url>%2F2018%2F01%2F23%2FPython%2F2018-01-23%2F</url>
    <content type="text"><![CDATA[本来我是要写一个删除数据库日志的脚本来辅助工作(这个脚本故事放到以后再说)，因为考虑到数据库删除后没有数据备份，当时想着可以在删除操作之前把查询到的数据库记录挑选几个主键外键写到本地 excel 内, 所以简单学习了一下 python 对 excel 的操作。 值得注意的是， xlrd 和 xlwt 是分开的两个库，另外还有功能补充的 xlutils 库。安装时候需要分别执行： 123pip install xlrdpip install xlwtpip install xlutils 并且在使用的时候，如果要使用也要分别 import 导入。 以下是 xlrd/xlwt 的基础操作： xlrd 读取数据1234567891011121314151617181920212223242526272829&gt;&gt;&gt; import xlrd,xlwt,os&gt;&gt;&gt; wb = xlrd.open_workbook(&apos;/Users/fuyiweng/Downloads/源码/Python处理Excel入门/input.xls&apos;)#获得所有表格名&gt;&gt;&gt; print(wb.sheet_names())[&apos;data&apos;]#通过sheet名或序号得到表格&gt;&gt;&gt; sheet = wb.sheet_wb.sheet_by_index( wb.sheet_by_name( wb.sheet_loaded(wb.sheet_names(&gt;&gt;&gt; sheet = wb.sheet_by_name(&apos;data&apos;)#获得 data 表 行列数&gt;&gt;&gt; print(sheet.nrows)11&gt;&gt;&gt; print(sheet.ncols)3#打印第一行&gt;&gt;&gt; print(sheet.row(0))[text:&apos;时间&apos;, text:&apos;人数1&apos;, text:&apos;人数2&apos;]&gt;&gt;&gt; print(sheet.row(1))[xldate:42736.0, number:16.0, number:26.0]#获取单元格&gt;&gt;&gt; print(sheet.cell(1,2))number:26.0#ctype = 1 # 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error&gt;&gt;&gt; print(sheet.cell(1,2).ctype)2&gt;&gt;&gt; print(sheet.cell(1,2).value)26.0 另外读取的时候注意，所读取的数据是否是以下xlrd 对 excel 内容分成的 7 种枚举类型 123456789(XL_CELL_EMPTY,XL_CELL_TEXT,XL_CELL_NUMBER,XL_CELL_DATE,XL_CELL_BOOLEAN,XL_CELL_ERROR,XL_CELL_BLANK, # for use in debugging, gathering stats, etc) = range(7) xlwt 写入数据打开 excel 文件123456789&gt;&gt;&gt; import xlrd,xlwt,os #通过xlrd 打开excel 文件&gt;&gt;&gt; wb = xlrd.open_workbook(&apos;/Users/fuyiweng/Downloads/源码/Python处理Excel入门/input.xls&apos;)&gt;&gt;&gt; type(wb)&lt;class &apos;xlrd.book.Book&apos;&gt; #通过xlwt.Workbook()转为可写模式&gt;&gt;&gt; wb = xlwt.Workbook()&gt;&gt;&gt; type(wb)&lt;class &apos;xlwt.Workbook.Workbook&apos;&gt; 写入数据1sheetname.write(row,col,value,style) 这里的 style 其实就是这个内容单元格的格式。 123456#写入第一行,标题栏style=xlwt.easyxf(&apos;align: vertical center, horizontal center&apos;)wsheet.write(0,0,u&apos;时间&apos;,style)wsheet.write(0,1,u&apos;人数1&apos;,style)wsheet.write(0,2,u&apos;人数2&apos;,style)wsheet.write(0,3,u&apos;总分&apos;,style)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>excel</tag>
        <tag>xlrd/xlwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟训练营第二期]]></title>
    <url>%2F2018%2F01%2F19%2FPython%2F2018-01-19-1%2F</url>
    <content type="text"><![CDATA[这是菜鸟训练营的第二期，主要是文件目录相关的问题，第三期的内容是数据分析相关的题目，我可能不会再继续去做了 原题：题目：mini文件搜索工具每个人电脑上都安装了Python无论是py2.7还是py3.6,假如你的是py2.7:搜索整个py2.7下面的所有目录(包括子目录)，里面的所有文件: 统计出整个py2.7目录下一共有多少个文件夹和文件 找到文件大小最大的哪个文件 找到文件名最长的哪个文件 解题：123456789101112131415161718192021222324252627282930313233343536373839404142434445from __future__ import divisionimport ospath=&apos;/Users/fuyiweng/Desktop/hero&apos;def search_file(path): folders = [] files_info = [] if not os.path.exists(path): print(&apos;Path : &#123;&#125; not exists!&apos;.format(path)) return None for root,dirs,files in os.walk(path): folders.extend(dirs) for f in files: #得到文件全路径，需要使用os.path.join(dirpath, name). f_path=os.path.join(root,f) #得到文件大小 f_size=round(os.path.getsize(f_path),3) files_info.append((f,f_size,f_path)) display(folders,files_info)def display(folders,files_info): print(&apos;folders: &apos;,folders) print(&apos;files_info &apos;,files_info) longest_file=sorted(files_info,key=lambda x:len(x[0]),reverse=True)[0][0] largest_file=sorted(files_info,key=lambda x:x[1],reverse=True)[0][2] largest_file_size=sorted(files_info,key=lambda x:(x[1]),reverse=True)[0][1] print(&apos;Total folders:&#123;&#125;,Total files:&#123;&#125;&apos;.\ format(len(folders),len(files_info))) print(&apos;Longest file name:&#123;&#125;,len:&#123;&#125;&apos;.\ format(longest_file,len(longest_file))) print(&apos;Largest file name:&#123;&#125; : size:&#123;&#125;&apos;.\ format(largest_file,str(round(largest_file_size/1024/1024))+&apos;M&apos;)) print(&apos;Total size:&#123;&#125;&apos;.format(sum([item[1] for item in files_info])))search_file(path) 解析：通过函数 os.walk() 函数来获取指定路径下的所存在的文件夹、文件、文件路径，将文件信息 append() 函数增加到列表中，然后通过 sorted() 排序，展示文件信息。 format格式化函数，基本语法是通过 {} 和 : 来代替以前的 % 。 不限个参数，位置可以不按顺序12345678&gt;&gt;&gt;&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序&apos;hello world&apos; &gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&apos;hello world&apos; &gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&apos;world hello world&apos; 设置参数123456789print(&quot;名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;wengfe&quot;, url=&quot;https://wengfe.github.io/&quot;)) # 通过字典设置参数site = &#123;&quot;name&quot;: &quot;日暮&quot;, &quot;url&quot;: &quot;https://wengfe.github.io/&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site)) # 通过列表索引设置参数my_list = [&apos;日暮&apos;, &apos;https://wengfe.github.io/&apos;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list)) # &quot;0&quot; 是必须的 数字格式化12&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926));3.14 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 -3.1415926 {:+.2f} 3.14 -3.14 带符号保留小数点后两位 3.1415926 {:.0f} 3 不保留小数 5 {:0&gt;2d} 05 数字补零，填充左侧，宽度2 5 {:x&lt;4d} 5xxx 数字补x，填充右侧，宽度4 10000000 {:,} 10,000,000 以逗号分隔数字 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数计数 13 {:10d} 13 右对齐，(默认)宽度10 13 {:&lt;10d} 13 左对齐，宽度10 13 {:^10d} 13 中间对齐，宽10 进制转换以十进制 11 为例：12345678910111213&apos;&#123;:b&#125;&apos;.format(11) &apos;&#123;:d&#125;&apos;.format(11)&apos;&#123;:o&#125;&apos;.format(11)&apos;&#123;:x&#125;&apos;.format(11)&apos;&#123;:#x&#125;&apos;.format(11)&apos;&#123;:#X&#125;&apos;.format(11) 10111113b0xb0XB 此外我们可以使用大括号 {} 来转义大括号，如下实例 1print (&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;.format(&quot;here&quot;)) os.walk因为 format 占据了很大的篇幅，所以就简单说一下 os.walk.os.walk() 方法用于通过在目录树种游走输出在目录中的文件名，向上或者向下。 walk()方法语法格式： 1os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) top 是你所要便利的目录的地址 topdown 为真，则优先遍历top目录，否则优先遍历top的子目录(默认为开启) onerror 需要一个 callable 对象，当walk需要异常时，会调用 followlinks 如果为真，则会遍历目录下的快捷方式(linux 下是 symbolic link)实际所指的目录(默认关闭) os.walk 的返回值是一个生成器,需要不断遍历，来获得所有的内容。 每次遍历返回的对象都是三元组(root,dirs,files) root 所指的是当前正在遍历的这个文件夹的本身的地址dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)如果topdown 参数为真，walk 会遍历top文件夹，与top文件夹中每一个子目录。 简单实例： 12345import osfor root, dirs, files in os.walk(path): print(root) print(dirs) print(files) format 参考链接: http://www.runoob.com/python/att-string-format.html 菜鸟教程 os.walk 参考链接: http://www.runoob.com/python/os-walk.html 菜鸟教程 https://www.jianshu.com/p/bbad16822eab MikuLovely]]></content>
      <categories>
        <category>python</category>
        <category>exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>菜鸟训练营</tag>
        <tag>sorted</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟训练营第一期]]></title>
    <url>%2F2018%2F01%2F19%2FPython%2F2018-01-19%2F</url>
    <content type="text"><![CDATA[我刚刚学习 Python 的时候就加入了一个小密圈，现在应该说是星球了。当时感觉水平次的很，当然现在也是只能谢谢寻常的逻辑代码。别说高级应用，甚至几个高级函数也不会用几个。不过自觉应该可以去做一下之前星球里的题目了。 因为自己写的代码比较无趣就贴上星主的代码。 第七题原题：有一串长的字符串 names=”LI XIA ,ZHAO MING ,LAO WANG *,DA XIONG &gt;,LI MEI MEI,CHANG JIANG,LI QIANG,ZHANG WU JI,ZHANG SAN FENG,DU GU QIU BAI,QIAO FENG” 要求： 过滤出所以的名字，去掉每个名字的左右的空格和乱码，每个名字的首字母大小比如’LAO WANG *’，处理成’Lao Wang’ 统计出所有名字里面名字最长 统计出同姓的人的名单 解题：12345678910names = &apos;LI XIA ,ZHAO MING ,LAO WANG *,DA XIONG &gt;,LI MEI MEI,&apos;\ &apos;CHANG JIANG,LI QIANG,ZHANG WU JI,ZHANG SAN FENG,&apos;\ &apos;DU GU QIU BAI,QIAO FENG&apos;def problem7(names): names_dict = &#123;name.title().strip(&apos; &gt;*&apos;):len(name) for name in names.split(&apos;,&apos;)&#125; print(sorted(names_dict.items(),key=lambda x:x[1],reverse=True))problem7(names) 解析两句代码解题，sorted 排序key 指定为名字长度，逆序排序增加属性 reverse=True 另外增加sorted 和 sort 的区别 函数 用法 效果 sorted sorted(a) 返回排序后的对象，不改变原对象顺序 sort a.sort() 改变原对象的排列顺序 第八题原题:数字1到5可以被写成:one,two,three,four,five,因此这些字母的总长度为:3+3+5+4+4=19,现在求序列1到1000(包括1000),这些数字写成单词，总长度为多少？ 注意: 比如 342(three hundred and forty-two)为23字母,空格和-不计算 比如 115(one hundred and fifteen)为20个字母 比如 1000(one hundred)为11个字母 解题:12345678910111213141516171819202122232425262728293031323334353637383940414243444546mapping=&#123;1:&apos;one&apos;,2:&apos;two&apos;,3:&apos;three&apos;,4:&apos;four&apos;,5:&apos;five&apos;, 6:&apos;six&apos;,7:&apos;seven&apos;,8:&apos;eight&apos;,9:&apos;nine&apos;,10:&apos;ten&apos;, 11:&apos;eleven&apos;,12:&apos;twelve&apos;,13:&apos;thirteen&apos;,14:&apos;fourteen&apos;,15:&apos;fifteen&apos;, 16:&apos;sixteen&apos;,17:&apos;seventeen&apos;,18:&apos;eighteen&apos;,19:&apos;nineteen&apos;,20:&apos;twenty&apos;, 30:&apos;thirty&apos;,40:&apos;forty&apos;,50:&apos;fifty&apos;,60:&apos;sixty&apos;,70:&apos;seventy&apos;, 80:&apos;eighty&apos;,90:&apos;ninety&apos;,100:&apos;hundred&apos;,1000:&apos;thousand&apos;&#125;def less_than_twenty(n): if n &lt;= 20 and n &gt;0: return mapping[n]def less_than_hundred(n): if n &gt; 20 and n &lt; 100: a,b = int(n/10),n%10 return mapping[a*10] if b == 0 else mapping[a*10]+mapping[b]def less_than_thousand(n): words=[] if n &gt;= 100 and n &lt;1000: a,b = int(n/100),n%100 words.append(mapping[a]) words.append(mapping[100]) if b&gt;0 and b&lt;=20: words.append(&apos;and&apos;) words.append(less_than_twenty(b)) if b&gt;20: words.append(&apos;and&apos;) words.append(less_than_hundred(b)) return &apos;&apos;.join(words)def get_words(n): if n&gt;0 and n&lt;=20: return less_than_twenty(n) elif n&lt;100: return less_than_hundred(n) elif n&gt;=100 and n&lt;1000: return less_than_thousand(n) elif n == 1000: return &apos;onethousand&apos;res = map(get_words,[x for x in range(1,1001)])print(sum(map(len,res))) 解析:此题中主要用到的点有 elif、join()、map函数以及用到了上一篇文章中 简介的 if/else 用法。 原理很简单，代码也很简单。先通过创建可哈希的字典对象，方便后面直接通过数字映射单词。然后通过判断区间，进行分别单词的获取。 map 函数是一个高级函数，接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 与之相似的还有 reduce 函数。把一个函数作用在一个序列上，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算， 我之前在学 python 的时候，和 reduce 一起学的，有笔记，但是抄笔记是一件麻烦又无趣的事，如果后面又学到相关的高级应用，再贴代码吧。]]></content>
      <categories>
        <category>python</category>
        <category>exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>菜鸟训练营</tag>
        <tag>map</tag>
        <tag>reduce</tag>
        <tag>sorted</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀代码一]]></title>
    <url>%2F2018%2F01%2F18%2FPython%2F%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B51%2F</url>
    <content type="text"><![CDATA[正所谓，人生苦短，我用 python 。在python 中，有非常多的令人影响深刻的好东西。 1.三目运算，if/else放在一行里面 12def test(m): return &apos;a&apos; if m==1 else &apos;b&apos; 2.构成一个字典序列 12print(dict(zip(&apos;abcd&apos;,range(4))) )&gt;&gt;&#123;&apos;a&apos;: 0, &apos;c&apos;: 2, &apos;b&apos;: 1, &apos;d&apos;: 3&#125; 3.print 中使用三目运算 1print(&apos;ok&apos; if a==1 else &apos;ko&apos;) 4.字符串切片的妙用 123 #列出1到20的数字，若是3的倍数就用apple代替，若是5的倍数就用orange代替， #若既是3的倍数又是5的倍数就用appleorange代替print [&apos;apple&apos;[i%35::]+&apos;orange&apos;[i%56::] or i for i in range(1,21)] 关键字or在上下文对算中，若有真假值，返回真值，若同为假值，返回最后一个假值 1234#&gt;&gt;&gt; print(&apos;&apos; or 1)1&gt;&gt;&gt; print(&apos;&apos;+&quot;&quot; or 1)1 5.推导列表生成字典 123list1=((1,&apos;a&apos;),(2,&apos;b&apos;))print(&#123;x[0]:x[1] for x in list1 &#125;)print(&#123;x:y for x in range(4) for y in range(10,14)&#125;) 6.漂亮的取表操作,字典排序 12345678910import heapqnums=[10,2,9,100,80]print heapq.nlargest(3,nums)print heapq.nsmallest(3,nums) students=[&#123;&apos;names&apos;:&apos;CC&apos;,&apos;score&apos;:100,&apos;height&apos;:189&#125;, &#123;&apos;names&apos;:&apos;BB&apos;,&apos;score&apos;:10,&apos;height&apos;:169&#125;, &#123;&apos;names&apos;:&apos;AA&apos;,&apos;score&apos;:80,&apos;height&apos;:179&#125;]print heapq.nsmallest(2,students,key=lambda x:x[&apos;height&apos;])]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>if/else</tag>
        <tag>code part</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F07%2FPython%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post` bash$ hexo new “My New Post”` More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
</search>
