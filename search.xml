<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MYSQL 查询优化]]></title>
    <url>%2F2018%2F02%2F08%2F2018-02-08%2F</url>
    <content type="text"><![CDATA[本文主要目的就是对数据库的优化查询，但查询过程中碰到了一个不明缘由的问题，希望有大神能够帮忙解释一波。 目的从 csv 文件中随机选取 100 条 Ip 地址，并在表中查询这 100条 ip 的所在地。 步骤 读取样本，组装列表 表建立索引 优化 sql 语法 联合查询 读取文件读取文件和上一篇文章所讲的一样，利用 with 语法避免文件句柄关闭操作，给 open 函数增加 encoding 参数。 然后将读取的数据进行拆分和整理： 123456789with open(&apos;./ipdata.csv&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: lines = f.readlines()nl_p_list = []for l in lines: ls = l.strip().split(&apos;,&apos;, 4) c1, c2, c3, c4, c5 = ls[0], ip2int(ls[1]), ip2int(ls[2]), ls[3], ls[4] nl = [c1, c2, c3, c4, c5] nl_p_list.append(nl) 表建立索引使用 navicat 连接表，进入 「设计表」 模块，为 startip 和 endip 建立索引。 优化 sql 语法如果使用复杂语法的 sql 语句，是无法利用索引大幅提升查询效率的，比如通过 between and 查询： SELECT * FROM ipdata WHERE IpNum BETWEEN startip AND endip 因为 ip 是连续的，所以只要这个 Ip 地址大于或等于某一个号段的起始地址，那么依照降序排序第一的 ip 段的所在地，就是被查询的 ip 地址的所在地。 SELECT * FROM ipdata WHERE IpNum &gt;= startip ORDER BY startip DESC LIMIT 1 经过对比发现，查询速度果然是有质的飞跃。但也出现了问题。问题详情我会在文末写明。 联合查询利用索引的 sql 语句果然是如有神助，在我的运行环境里， between and 查询语句，查询 100 条记录需要 32s+ ，但在优化后能提升到 0.7s 左右。 但是在使用联合查询后，还能提升将近 2 倍的速率。 联合查询的 sql 语法： 123SELECT t1.* FROM (SELECT * FROM ipdata WHERE 1780997668 &gt;= startip ORDER BY startip DESC LIMIT 1) t1UNION ALLSELECT t2.* FROM (SELECT * FROM ipdata WHERE 3425736747 &gt;= startip ORDER BY startip DESC LIMIT 1) t2; 下一步，就是加工 sql 联合语句了。联合查询的 sql 语句，不宜过长，比较适合的长度就是 100 条。 1234sql_str = &apos;SELECT &#123;0&#125;.* FROM (SELECT * FROM ipdata WHERE %s &gt;= startip ORDER BY startip DESC LIMIT 1) &#123;0&#125;&apos;for i in range(len(ip_list)): sql_list.append(sql_str.format(&apos;t&apos; + str(i)) % ip_list[i])sql = &apos; union all &apos;.join(sql_list) 使用 format 函数填充别名， %s 填充 IP 地址 。最后执行 sql 语句： 1cursor.execute(sql) 效果也是有的，将查询的速度提升到了 0.3s 左右。 至此， sql 的数据表查询优化部分那就结束了。 遇到的灵异现象如图所示，我注释了 t1, t2, t3, t4 之间的代码。 时间段 含义 运行速度 t0 ~ t1 联合优化 sql 语句查询 0.0318 t1 ~ t2 优化 sql 语句查询 9.5367 t3 ~ t2 between and 语句查询 1.1920 t4 ~ t3 联合 between and 语句查询 0.0 事实上，除了 t0 ~ t1 之间的时间是大致在 0.03s ~ 0.07s 波动，剩余的三个时间段的代码已经被我注释，理论上应该是不耗费时间的，但会随机在剩余的三个时间段 打印出 9s 左右的耗时。希望有大神能够帮助一波。 源码地址: 『NiuCodeLesson/insertSQL/』：https://github.com/wengfe/NiuCodeLesson/tree/master/insertSQL]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL 批量插入操作]]></title>
    <url>%2F2018%2F02%2F07%2F2018-02-07%2F</url>
    <content type="text"><![CDATA[对数据库的增删改查平时的工作中用的比较多，也比较熟悉。忽然发现都没有使用过 insert 操作，因此在学习 python 的过程中，通过 mysql.connector 对 44w行 的 ip地址记录进行数据库批量插入工作。 步骤分为以下五步： 1. 数据格式整理 2. 创建表 3. 连接表 4. 读取本地文件数据 5. 批量写入 数据格式整理首先查看所拿到的数据，并整理：分别在终端中使用 head ipdata.csv 和 tail ipdata.csv 来查看文件的头部和尾部数据，对其规律进行分析。 12345678910111213141516171819202122:~/Documents/study/NiuCodeLesson/insertSQL% head ipdata.csv1,0.0.0.0,0.255.255.255,IANA,保留地址2,1.0.0.0,1.0.0.255,澳大利亚,CZ88.NET3,1.0.1.0,1.0.3.255,福建省,电信4,1.0.4.0,1.0.7.255,澳大利亚,CZ88.NET5,1.0.8.0,1.0.15.255,广东省,电信6,1.0.16.0,1.0.31.255,日本,Beacon服务器7,1.0.32.0,1.0.63.255,广东省,电信8,1.0.64.0,1.0.127.255,日本,広島県中区大手町Energia通信公司9,1.0.128.0,1.0.255.255,泰国,CZ88.NET10,1.1.0.0,1.1.0.255,福建省,电信:~/Documents/study/NiuCodeLesson/insertSQL% tail ipdata.csv444954,223.255.252.0,223.255.253.255,福建省,电信444955,223.255.254.0,223.255.254.255,新加坡,滨海湾金沙私人有限公司444956,223.255.255.0,223.255.255.255,澳大利亚,CZ88.NET444957,224.0.0.0,224.255.255.255,IANA,CZ88.NET444958,225.0.0.0,239.255.255.255,IANA保留地址,用于多点传送444959,240.0.0.0,247.255.255.255,IANA保留地址,CZ88.NET444960,248.0.0.0,248.255.255.255,IANA保留地址,CZ88.NET444961,249.0.0.0,254.255.255.255,IANA保留地址,CZ88.NET444962,255.0.0.0,255.255.254.255,CZ88.NET,444963,255.255.255.0,255.255.255.255,纯真网络,2014年10月25日IP数据 查看后我们可以大致将数据分为 5 列，「序号」，「起始IP」，「终止IP」，「所在地」，「运营商」。 创建表经过格式的分析，我们就可以创建一个表的结构了。注：事实上分析数据规律比建表要重要的多，因为本文重点不在此处，所以概过。 首先通过 navicat 创建本地的数据库。数据库格式如下图： 连接表首先连接本地数据库因为我的表示创建在本地数据库下的，连接的库的时候不需要添加 host 参数连接本地数据库的代码如下： 1conn = mysql.connector.connect(user=&apos;root&apos;, password=&apos;admin&apos;, database=&apos;test&apos;) 连接远程数据库的代码如下： 1conn = connection.MySQLConnection(host=host_d, user=user_d, password=password_d, database=database_d) 读取 csv 数据文件一般来说，读取文件的方法有两种；推荐以下方式来读取文件，可以避免忘记关闭文件句柄的尴尬： 12with open(&apos;./ipdata.csv&apos;, &apos;r&apos;) as f: lines = f.readlines() 读取文件格式采坑在读取文件的过程中发现了报错。 报错信息：1UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 29: ordinal not in range(128) 原因分析：出错的原因是因为 csv 内的编码方式与程序环境编码方式不一致所致。csv 的编码格式是 gbk， 只要能够用 unicode 编码格式处理读取进来的数据就解决了。 搜索解决方案：自从上次瞎捷豹连续操劳后，已经很久没有让它出门了，这次又要有劳它了。经过搜索后，发现很多方案： 方案一 代码头部申明编码有两种写法，然而在试验后，表示并没有解决问题ㄟ( ▔, ▔ )ㄏ。 1# -*- coding: utf-8 -*- 1# coding = utf-8 方案二 IDE 设置编码格式虽然在 「偏好设置 - Editor - File Encodings」 内全都设置（默认设置）了 UTF-8，但是在读入数据文件 ipdata.csv 的时候，还是出现了错误。我也很奇怪为什么没有生效。 方案三 修改默认 encoding 格式 在代码头部导入 sys 库； 重载 sys 库，网上说 Python 文件运行后，会删除 setdefaultencoding 方法？ 设置默认 encoding 格式。 123import sysreload(sys) sys.setdefaultencoding(&apos;utf-8&apos;) 运行后显示找不到 setdefaultending 方法. 瞎捷豹愤而暴走，告诉我因为在 py3 中默认的编码格式为 unicode 解码？所以取消了 setdefaultending 方法。 正解：引入 codecs 库codecs 库中的 open 方法可以添加 encoding 参数，完美解决。 1234import codecswith open(&apos;./ipdata.csv&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: lines = f.readlines() 后来发现其实 3.6 版本的 py 早就集成了 open 函数的 encoding 参数。所以并不用导入 codecs 库。 批量写入插入操作的 sql 写法为 : 1insert into tablename (key1, key2, key3...) values (value1, value2, value3...) 使用 cursor.executemany() 方法来执行批量插入操作 方法为： 12cursor = conn.cursor()ret = cursor.executemany(&apos;insert into ipdata (id, startip, endip, country, carrier) values (%s, %s, %s, %s, %s)&apos;, nl_p_list) 失去连接报错12055: Lost connection to MySQL server at &apos;127.0.0.1:3306&apos;, system error: 32 Broken pipe 猜测是数据量太大所致，所以对读入的文件进行切片，分批插入表中； 12345for i in range(int(len(nl_p_list)/1000 +1)): tmp_nl_p_list = nl_p_list[i*1000: (i+1)*1000] # 批量插入表中 ret = cursor.executemany(&apos;insert into ipdata (id, startip, endip, country, carrier) values (%s, %s, %s, %s, %s)&apos;, tmp_nl_p_list) 数据库插入中文错误出现了新的报错，查看报错信息： 11366 (HY000): Incorrect string value: &apos;\xE4\xBF\x9D\xE7\x95\x99...&apos; for column &apos;carrier&apos; at row 1 对报错信息显示 异常的 string 值，截取报错信息交给瞎捷豹，很快找到了解决方案；还是编码格式锅，不过这次是表结构编码格式不符。 在 navicat 表设计 - DDL 中查看 ipdata 的表结构： 12345678CREATE TABLE `ipdata` ( `id` int(11) NOT NULL, `startip` bigint(20) DEFAULT NULL, `endip` bigint(20) DEFAULT NULL, `country` text, `carrier` text, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1; 发现表编码为 latin1 。 果然不是 utf-8。通过 navicat 查询功能修改表编码格式，输入代码并执行： 1alter table ipdata convert to character set utf8; 重新查看表结构： 12345678CREATE TABLE `ipdata` ( `id` int(11) NOT NULL, `startip` bigint(20) DEFAULT NULL, `endip` bigint(20) DEFAULT NULL, `country` text, `carrier` text, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 重新运行代码，数据成功写入表中。 使用 navicat 的查询功能： select count(*) from ipdata 得到记录行数 444963，写入记录正常。 计划通！ 参考链接： 『mysql.connector 批量插入』：https://my.oschina.net/hhdys412/blog/182762 源码地址: 『NiuCodeLesson/insertSQL/』：https://github.com/wengfe/NiuCodeLesson/tree/master/insertSQL]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy-ORM]]></title>
    <url>%2F2018%2F02%2F06%2F2018-02-06%2F</url>
    <content type="text"><![CDATA[上一篇所用的代码，是廖雪峰大大 python 数据库章节中的 SQLAlchemy 中的部分。因为踩到不少坑，所以又找到相关的资料进行学习。这一片主要将 sqlalchemy-orm 部分进行总结。ORM（Object Relational Mapper）可以理解为「将数据库中的表映射为程序中的类」。表中的一行即为该类的一个实例。 在使用 sqlalchemy 之前，需要先导入相关的库，在导入之前当然也是需要先安装。因为在代码中写入了大量的注释，所以就多 BB 了，文末会贴上本文代码的 github 的项目地址。在终端输入： 1pip install sqlalchemy 打开 pycharm 新建一个项目，然后导入以下库： 12345import sqlalchemyfrom sqlalchemy import create_engine, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, String, Integerfrom sqlalchemy.orm import sessionmaker 注：第二行的最后一个库是之后双表建立外键的时候需要添加的库 创建「表-类」映射创建表123456789101112131415161718192021222324# 利用数据库字符串构造engine, echo为True将打印所有的sql语句engine = create_engine(&apos;sqlite:///foo.db&apos;, echo=True)# 首先需要生成一个BaseModel类,作为所有模型类的基类Base = declarative_base()class User(Base): __tablename__ = &apos;user&apos; id = Column(Integer, primary_key=True) name = Column(String) fullname = Column(String) passward = Column(String) def __repr__(self): return &apos;&lt;User(name=&quot;%s&quot;, fullname=&quot;%s&quot;, passward=&quot;%s&quot;)&gt;&apos; % ( self.name, self.fullname, self.passward)# 创建所有表,如果表已经存在,则不会创建# Base.metadata.create_all(engine)# 删除所有表# Base.metadata.drop_all(engine) 创建表实例创建一个 User 实例， sqlalchemy ORM 通过 session（会话）来操作表，一个 session 实例可以添加多个事务，然后通过 commit 提交事务，未提交的表操作事务是不会反馈到表中。 123456789101112131415161718192021222324#创建一个 User 类实例ed_user = User(name=&apos;ed&apos;, fullname=&apos;Ed jones&apos;, passward=&apos;edspassward&apos;)# print(ed_user)# 利用Session对象连接数据库#创建会话类和会话类的对象Session = sessionmaker(bind=engine)session = Session()# 向事务会话中添加实例对象，向表中插入数据需要提交事务， 调用 commit() 方法# session.add(ed_user)##查询符合条件的第一条# our_user = session.query(User).filter_by(name=&apos;ed&apos;).first()# 相等于下方的 sql 语句# select * from User where name=&apos;ed&apos; limit 1;## session.add_all([# User(name=&apos;wendy&apos;, fullname=&apos;Wendy Williams&apos;, passward=&apos;foobar&apos;),# User(name=&apos;wendy2&apos;, fullname=&apos;Wendy Williams&apos;, passward=&apos;foobar&apos;),# User(name=&apos;wendy3&apos;, fullname=&apos;Wendy Williams&apos;, passward=&apos;foobar&apos;)# ])# session.commit() 通过 session 事务进行查询操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#查询全部# print(session.query(User).all())#查询符合条件的第一条# our_user = session.query(User).filter_by(name=&apos;ed&apos;).first()#排序# for row in session.query(User).order_by(User.id):# print(row)# 查询 in 操作# for row in session.query(User).filter(User.name.in_([&apos;ed&apos;, &apos;wendy&apos;])):# print(row)# 查询 not in 操作# for row in session.query(User).filter(~User.name.in_([&apos;ed&apos;, &apos;wendy&apos;])):# print(row)# count 操作# print(session.query(User).filter(User.name ==&apos;ed&apos;).count())# and 和 or 操作, 需要导入模块# from sqlalchemy import and_, or_# for row in session.query(User).filter(and_(User.name == &apos;ed&apos;, User.fullname == &apos;Ed jones&apos;)):# print(row)# for row in session.query(User).filter(or_(User.name == &apos;ed&apos;, User.name ==&apos;wendy&apos;)):# print(row)# 创建外键from sqlalchemy import ForeignKeyfrom sqlalchemy.orm import relationship, backrefclass Address(Base): __tablename__ = &apos;addresses&apos; id = Column(Integer, primary_key=True) email_address = Column(String, nullable=False) user_id = Column(Integer, ForeignKey(&apos;user.id&apos;)) # 关联 User 表主键为外键，此处为 多对1 user_i = relationship(&quot;User&quot;, backref=backref(&apos;addresses&apos;, order_by=id)) def __repr__(self): return &quot;&lt;Address(email_address=&apos;%s&apos;)&gt;&quot; % self.email_address# Base.metadata.create_all(engine)# jack = User(name=&apos;jack&apos;, fullname=&apos;Jack Bean&apos;, passward=&apos;giffs&apos;)# jack.addresses = [# Address(email_address=&apos;jack@google.com&apos;),# Address(email_address=&apos;j25@yahoo.com&apos;)]## session.add(jack)# session.commit()# 双表联合查询for u, a in session.query(User, Address).\ filter(User.id == Address.user_id).\ filter(Address.email_address == &apos;jack@google.com&apos;).\ all(): print(u, a) 表数据修改操作123456789101112# 表修改# 造数据he_user = User(id=15, name=&apos;he&apos;, fullname=&apos;He jones&apos;, passward=&apos;edspassward&apos;)# session.add(he_user)# session.commit()# 使用merge方法，如果指定的主键已存在，修改记录，不存在新增一条记录session.merge(he_user)session.commit()# 关闭 sessionsession.close() github 地址：NiuCodeLesson/SQLalchemytest/SQLAlchemy.py]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>SQLAlchemy</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy 预使用 -- 本地环境配置]]></title>
    <url>%2F2018%2F02%2F01%2F2018-02-01%2F</url>
    <content type="text"><![CDATA[因为之前使用 Python 操作数据库表时，目的是为了辅助工作，所以是直接对公司测试服务器上的数据库进行操作的。这次因为在学习 ORM ，所以需要在本地创建数据库。踩了一堆的烂坑，不得不说，大学时候没有听一节课，付出的时间代价会更大，我花了一天的时间进行踩坑学习才补回。 SQLAlchemy 是 python 平台上较为成熟的 ORM 框架。ORM -&gt; 对象关系映射，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”抛开百度百科，就我的使用方向说，就是建立函数与数据库表之间的映射关系，所以需要映射的数据库表的是需要事先创建好的。我就是在这里踩了大坑。 安装本地 MySQL首先需要启动本地的 MySQLserver，我使用的是 Mac，前往官网下载，直接安装就好了。安装好后会给你一个随机密码。请记住这个密码。 当然忘记了问题也不大。 链接本地数据库这里问题就有点多了，当我安装好 MySQL 后，打开 Navicat 新建本地数据库链接的时候，跳出很多的小问题。 Can’t connect to remote MySQL server with error 61一只瞎捷豹乱搜，找到原因： Mac 下安装mysql，安装完成后是无用户无密码的状态，并且数据库只有 information_schema 也找到了解决之道: 为 root 账户新建密码。 鬼知道为什么无用户无密码状态，还给了我一个默认密码。按照随便找到的解决方法指导： [x] 关闭本地 MySQL 服务（在系统偏好设置的最下面一栏） [x] 进入 MySQL 文件目录下 [x] 启动超级账户 [x] 安全模式启动 MySQL [ ] 另起终端，使用 root 用户启动 MySQL:执行 mysql -u root [ ] 为root用户设置新的密码 UPDATE mysql.user SET Password=PASSWORD(&#39;password&#39;) WHERE User=&#39;root&#39;; [ ] 刷新，生效设置。FLUSH PRIVILEGES; 1234567/usr/local/mysql/binsudo suPassword:sh-3.2# ./mysqld_safe --skip-grant-tables &amp;[1] 33563sh-3.2# 2018-02-01T05:43:01.6NZ mysqld_safe Logging to &apos;/usr/local/mysql-5.7.21-macos10.13-x86_64/data/fuyiwengdeMacBook-Pro.local.err&apos;.2018-02-01T05:43:01.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.21-macos10.13-x86_64/data 嗯，没错，我卡在了第五步 T&gt;T。 终端启用 MySQL 命令经过了惨无人道的瞎捷豹二次搜索，又成功找到了答案。 首先查看是否已添加 MySQL 的 PATH 路径 echo $PATH 如果能找到 mysql 的 PATH 路径（这是不可能的），问题解决 找不到，添加 MySQL 的路径，PATH=&quot;$PATH&quot;:/usr/local/mysql/bin 查看是否添加成功 12$ which mysql/usr/local/mysql/bin/mysql 如上所示，就是添加成功，我们可以继续放回上一个问题继续操作了。注：添加的 MySQL 路径为临时路径，关闭此终端后，下次打开将不再能运行 Your password has expired. To log in you must change it using a client that supports expired passwords.whatFuc—-A?瞎捷豹有点累，所以这次凭着我的三级英语，解密了这英文。密码过期，需要改密码。所以我刚刚改的是一个加密码？/usr/local/mysql/bin/mysqladmin -u root -p password输入旧密码，新密码。 然后就碰上了交学费的问题。 1049 (42000): Unknown database ‘test’ 和 1146 (42S02): Table ‘test.user’ doesn’t exist在之前配置了 MySQL 路径的终端中 使用 mysql 命令，show databases 果然发现没有需要链接的表。 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 创建数据库和表吧，这里对自己的蠢不予置评。 Q^Q 我竟然还在这花了1个小时。 再次运行代码，皆大欢喜。 参考链接：终端数据库管理修改数据库密码]]></content>
      <categories>
        <category>python</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>SQLAlchemy</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 xlrd,xlwt 操作 excel]]></title>
    <url>%2F2018%2F01%2F23%2F2018-01-23%2F</url>
    <content type="text"><![CDATA[本来我是要写一个删除数据库日志的脚本来辅助工作(这个脚本故事放到以后再说)，因为考虑到数据库删除后没有数据备份，当时想着可以在删除操作之前把查询到的数据库记录挑选几个主键外键写到本地 excel 内, 所以简单学习了一下 python 对 excel 的操作。 值得注意的是， xlrd 和 xlwt 是分开的两个库，另外还有功能补充的 xlutils 库。安装时候需要分别执行： 123pip install xlrdpip install xlwtpip install xlutils 并且在使用的时候，如果要使用也要分别 import 导入。 以下是 xlrd/xlwt 的基础操作： xlrd 读取数据1234567891011121314151617181920212223242526272829&gt;&gt;&gt; import xlrd,xlwt,os&gt;&gt;&gt; wb = xlrd.open_workbook(&apos;/Users/fuyiweng/Downloads/源码/Python处理Excel入门/input.xls&apos;)#获得所有表格名&gt;&gt;&gt; print(wb.sheet_names())[&apos;data&apos;]#通过sheet名或序号得到表格&gt;&gt;&gt; sheet = wb.sheet_wb.sheet_by_index( wb.sheet_by_name( wb.sheet_loaded(wb.sheet_names(&gt;&gt;&gt; sheet = wb.sheet_by_name(&apos;data&apos;)#获得 data 表 行列数&gt;&gt;&gt; print(sheet.nrows)11&gt;&gt;&gt; print(sheet.ncols)3#打印第一行&gt;&gt;&gt; print(sheet.row(0))[text:&apos;时间&apos;, text:&apos;人数1&apos;, text:&apos;人数2&apos;]&gt;&gt;&gt; print(sheet.row(1))[xldate:42736.0, number:16.0, number:26.0]#获取单元格&gt;&gt;&gt; print(sheet.cell(1,2))number:26.0#ctype = 1 # 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error&gt;&gt;&gt; print(sheet.cell(1,2).ctype)2&gt;&gt;&gt; print(sheet.cell(1,2).value)26.0 另外读取的时候注意，所读取的数据是否是以下xlrd 对 excel 内容分成的 7 种枚举类型 123456789(XL_CELL_EMPTY,XL_CELL_TEXT,XL_CELL_NUMBER,XL_CELL_DATE,XL_CELL_BOOLEAN,XL_CELL_ERROR,XL_CELL_BLANK, # for use in debugging, gathering stats, etc) = range(7) xlwt 写入数据打开 excel 文件123456789&gt;&gt;&gt; import xlrd,xlwt,os #通过xlrd 打开excel 文件&gt;&gt;&gt; wb = xlrd.open_workbook(&apos;/Users/fuyiweng/Downloads/源码/Python处理Excel入门/input.xls&apos;)&gt;&gt;&gt; type(wb)&lt;class &apos;xlrd.book.Book&apos;&gt; #通过xlwt.Workbook()转为可写模式&gt;&gt;&gt; wb = xlwt.Workbook()&gt;&gt;&gt; type(wb)&lt;class &apos;xlwt.Workbook.Workbook&apos;&gt; 写入数据1sheetname.write(row,col,value,style) 这里的 style 其实就是这个内容单元格的格式。 123456#写入第一行,标题栏style=xlwt.easyxf(&apos;align: vertical center, horizontal center&apos;)wsheet.write(0,0,u&apos;时间&apos;,style)wsheet.write(0,1,u&apos;人数1&apos;,style)wsheet.write(0,2,u&apos;人数2&apos;,style)wsheet.write(0,3,u&apos;总分&apos;,style)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>excel</tag>
        <tag>xlrd/xlwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟训练营第二期]]></title>
    <url>%2F2018%2F01%2F19%2F2018-01-19-1%2F</url>
    <content type="text"><![CDATA[这是菜鸟训练营的第二期，主要是文件目录相关的问题，第三期的内容是数据分析相关的题目，我可能不会再继续去做了 原题：题目：mini文件搜索工具每个人电脑上都安装了Python无论是py2.7还是py3.6,假如你的是py2.7:搜索整个py2.7下面的所有目录(包括子目录)，里面的所有文件: 统计出整个py2.7目录下一共有多少个文件夹和文件 找到文件大小最大的哪个文件 找到文件名最长的哪个文件 解题：123456789101112131415161718192021222324252627282930313233343536373839404142434445from __future__ import divisionimport ospath=&apos;/Users/fuyiweng/Desktop/hero&apos;def search_file(path): folders = [] files_info = [] if not os.path.exists(path): print(&apos;Path : &#123;&#125; not exists!&apos;.format(path)) return None for root,dirs,files in os.walk(path): folders.extend(dirs) for f in files: #得到文件全路径，需要使用os.path.join(dirpath, name). f_path=os.path.join(root,f) #得到文件大小 f_size=round(os.path.getsize(f_path),3) files_info.append((f,f_size,f_path)) display(folders,files_info)def display(folders,files_info): print(&apos;folders: &apos;,folders) print(&apos;files_info &apos;,files_info) longest_file=sorted(files_info,key=lambda x:len(x[0]),reverse=True)[0][0] largest_file=sorted(files_info,key=lambda x:x[1],reverse=True)[0][2] largest_file_size=sorted(files_info,key=lambda x:(x[1]),reverse=True)[0][1] print(&apos;Total folders:&#123;&#125;,Total files:&#123;&#125;&apos;.\ format(len(folders),len(files_info))) print(&apos;Longest file name:&#123;&#125;,len:&#123;&#125;&apos;.\ format(longest_file,len(longest_file))) print(&apos;Largest file name:&#123;&#125; : size:&#123;&#125;&apos;.\ format(largest_file,str(round(largest_file_size/1024/1024))+&apos;M&apos;)) print(&apos;Total size:&#123;&#125;&apos;.format(sum([item[1] for item in files_info])))search_file(path) 解析：通过函数 os.walk() 函数来获取指定路径下的所存在的文件夹、文件、文件路径，将文件信息 append() 函数增加到列表中，然后通过 sorted() 排序，展示文件信息。 format格式化函数，基本语法是通过 {} 和 : 来代替以前的 % 。 不限个参数，位置可以不按顺序12345678&gt;&gt;&gt;&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序&apos;hello world&apos; &gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&apos;hello world&apos; &gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&apos;world hello world&apos; 设置参数123456789print(&quot;名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;wengfe&quot;, url=&quot;https://wengfe.github.io/&quot;)) # 通过字典设置参数site = &#123;&quot;name&quot;: &quot;日暮&quot;, &quot;url&quot;: &quot;https://wengfe.github.io/&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site)) # 通过列表索引设置参数my_list = [&apos;日暮&apos;, &apos;https://wengfe.github.io/&apos;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list)) # &quot;0&quot; 是必须的 数字格式化12&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926));3.14 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 -3.1415926 {:+.2f} 3.14 -3.14 带符号保留小数点后两位 3.1415926 {:.0f} 3 不保留小数 5 {:0&gt;2d} 05 数字补零，填充左侧，宽度2 5 {:x&lt;4d} 5xxx 数字补x，填充右侧，宽度4 10000000 {:,} 10,000,000 以逗号分隔数字 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数计数 13 {:10d} 13 右对齐，(默认)宽度10 13 {:&lt;10d} 13 左对齐，宽度10 13 {:^10d} 13 中间对齐，宽10 进制转换以十进制 11 为例：12345678910111213&apos;&#123;:b&#125;&apos;.format(11) &apos;&#123;:d&#125;&apos;.format(11)&apos;&#123;:o&#125;&apos;.format(11)&apos;&#123;:x&#125;&apos;.format(11)&apos;&#123;:#x&#125;&apos;.format(11)&apos;&#123;:#X&#125;&apos;.format(11) 10111113b0xb0XB 此外我们可以使用大括号 {} 来转义大括号，如下实例 1print (&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;.format(&quot;here&quot;)) os.walk因为 format 占据了很大的篇幅，所以就简单说一下 os.walk.os.walk() 方法用于通过在目录树种游走输出在目录中的文件名，向上或者向下。 walk()方法语法格式： 1os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) top 是你所要便利的目录的地址 topdown 为真，则优先遍历top目录，否则优先遍历top的子目录(默认为开启) onerror 需要一个 callable 对象，当walk需要异常时，会调用 followlinks 如果为真，则会遍历目录下的快捷方式(linux 下是 symbolic link)实际所指的目录(默认关闭) os.walk 的返回值是一个生成器,需要不断遍历，来获得所有的内容。 每次遍历返回的对象都是三元组(root,dirs,files) root 所指的是当前正在遍历的这个文件夹的本身的地址dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)如果topdown 参数为真，walk 会遍历top文件夹，与top文件夹中每一个子目录。 简单实例： 12345import osfor root, dirs, files in os.walk(path): print(root) print(dirs) print(files) format 参考链接: http://www.runoob.com/python/att-string-format.html 菜鸟教程 os.walk 参考链接: http://www.runoob.com/python/os-walk.html 菜鸟教程 https://www.jianshu.com/p/bbad16822eab MikuLovely]]></content>
      <categories>
        <category>python</category>
        <category>exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>菜鸟训练营</tag>
        <tag>format</tag>
        <tag>sorted</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟训练营第一期]]></title>
    <url>%2F2018%2F01%2F19%2F2018-01-19%2F</url>
    <content type="text"><![CDATA[我刚刚学习 Python 的时候就加入了一个小密圈，现在应该说是星球了。当时感觉水平次的很，当然现在也是只能谢谢寻常的逻辑代码。别说高级应用，甚至几个高级函数也不会用几个。不过自觉应该可以去做一下之前星球里的题目了。 因为自己写的代码比较无趣就贴上星主的代码。 第七题原题：有一串长的字符串 names=”LI XIA ,ZHAO MING ,LAO WANG *,DA XIONG &gt;,LI MEI MEI,CHANG JIANG,LI QIANG,ZHANG WU JI,ZHANG SAN FENG,DU GU QIU BAI,QIAO FENG” 要求： 过滤出所以的名字，去掉每个名字的左右的空格和乱码，每个名字的首字母大小比如’LAO WANG *’，处理成’Lao Wang’ 统计出所有名字里面名字最长 统计出同姓的人的名单 解题：12345678910names = &apos;LI XIA ,ZHAO MING ,LAO WANG *,DA XIONG &gt;,LI MEI MEI,&apos;\ &apos;CHANG JIANG,LI QIANG,ZHANG WU JI,ZHANG SAN FENG,&apos;\ &apos;DU GU QIU BAI,QIAO FENG&apos;def problem7(names): names_dict = &#123;name.title().strip(&apos; &gt;*&apos;):len(name) for name in names.split(&apos;,&apos;)&#125; print(sorted(names_dict.items(),key=lambda x:x[1],reverse=True))problem7(names) 解析两句代码解题，sorted 排序key 指定为名字长度，逆序排序增加属性 reverse=True 另外增加sorted 和 sort 的区别 函数 用法 效果 sorted sorted(a) 返回排序后的对象，不改变原对象顺序 sort a.sort() 改变原对象的排列顺序 第八题原题:数字1到5可以被写成:one,two,three,four,five,因此这些字母的总长度为:3+3+5+4+4=19,现在求序列1到1000(包括1000),这些数字写成单词，总长度为多少？ 注意: 比如 342(three hundred and forty-two)为23字母,空格和-不计算 比如 115(one hundred and fifteen)为20个字母 比如 1000(one hundred)为11个字母 解题:12345678910111213141516171819202122232425262728293031323334353637383940414243444546mapping=&#123;1:&apos;one&apos;,2:&apos;two&apos;,3:&apos;three&apos;,4:&apos;four&apos;,5:&apos;five&apos;, 6:&apos;six&apos;,7:&apos;seven&apos;,8:&apos;eight&apos;,9:&apos;nine&apos;,10:&apos;ten&apos;, 11:&apos;eleven&apos;,12:&apos;twelve&apos;,13:&apos;thirteen&apos;,14:&apos;fourteen&apos;,15:&apos;fifteen&apos;, 16:&apos;sixteen&apos;,17:&apos;seventeen&apos;,18:&apos;eighteen&apos;,19:&apos;nineteen&apos;,20:&apos;twenty&apos;, 30:&apos;thirty&apos;,40:&apos;forty&apos;,50:&apos;fifty&apos;,60:&apos;sixty&apos;,70:&apos;seventy&apos;, 80:&apos;eighty&apos;,90:&apos;ninety&apos;,100:&apos;hundred&apos;,1000:&apos;thousand&apos;&#125;def less_than_twenty(n): if n &lt;= 20 and n &gt;0: return mapping[n]def less_than_hundred(n): if n &gt; 20 and n &lt; 100: a,b = int(n/10),n%10 return mapping[a*10] if b == 0 else mapping[a*10]+mapping[b]def less_than_thousand(n): words=[] if n &gt;= 100 and n &lt;1000: a,b = int(n/100),n%100 words.append(mapping[a]) words.append(mapping[100]) if b&gt;0 and b&lt;=20: words.append(&apos;and&apos;) words.append(less_than_twenty(b)) if b&gt;20: words.append(&apos;and&apos;) words.append(less_than_hundred(b)) return &apos;&apos;.join(words)def get_words(n): if n&gt;0 and n&lt;=20: return less_than_twenty(n) elif n&lt;100: return less_than_hundred(n) elif n&gt;=100 and n&lt;1000: return less_than_thousand(n) elif n == 1000: return &apos;onethousand&apos;res = map(get_words,[x for x in range(1,1001)])print(sum(map(len,res))) 解析:此题中主要用到的点有 elif、join()、map函数以及用到了上一篇文章中 简介的 if/else 用法。 原理很简单，代码也很简单。先通过创建可哈希的字典对象，方便后面直接通过数字映射单词。然后通过判断区间，进行分别单词的获取。 map 函数是一个高级函数，接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 与之相似的还有 reduce 函数。把一个函数作用在一个序列上，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算， 我之前在学 python 的时候，和 reduce 一起学的，有笔记，但是抄笔记是一件麻烦又无趣的事，如果后面又学到相关的高级应用，再贴代码吧。]]></content>
      <categories>
        <category>python</category>
        <category>exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>菜鸟训练营</tag>
        <tag>sorted</tag>
        <tag>map</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀代码一]]></title>
    <url>%2F2018%2F01%2F18%2F%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B51%2F</url>
    <content type="text"><![CDATA[正所谓，人生苦短，我用 python 。在python 中，有非常多的令人影响深刻的好东西。 1.三目运算，if/else放在一行里面 12def test(m): return &apos;a&apos; if m==1 else &apos;b&apos; 2.构成一个字典序列 12print(dict(zip(&apos;abcd&apos;,range(4))) )&gt;&gt;&#123;&apos;a&apos;: 0, &apos;c&apos;: 2, &apos;b&apos;: 1, &apos;d&apos;: 3&#125; 3.print 中使用三目运算 1print(&apos;ok&apos; if a==1 else &apos;ko&apos;) 4.字符串切片的妙用 123 #列出1到20的数字，若是3的倍数就用apple代替，若是5的倍数就用orange代替， #若既是3的倍数又是5的倍数就用appleorange代替print [&apos;apple&apos;[i%35::]+&apos;orange&apos;[i%56::] or i for i in range(1,21)] 关键字or在上下文对算中，若有真假值，返回真值，若同为假值，返回最后一个假值 1234#&gt;&gt;&gt; print(&apos;&apos; or 1)1&gt;&gt;&gt; print(&apos;&apos;+&quot;&quot; or 1)1 5.推导列表生成字典 123list1=((1,&apos;a&apos;),(2,&apos;b&apos;))print(&#123;x[0]:x[1] for x in list1 &#125;)print(&#123;x:y for x in range(4) for y in range(10,14)&#125;) 6.漂亮的取表操作,字典排序 12345678910import heapqnums=[10,2,9,100,80]print heapq.nlargest(3,nums)print heapq.nsmallest(3,nums) students=[&#123;&apos;names&apos;:&apos;CC&apos;,&apos;score&apos;:100,&apos;height&apos;:189&#125;, &#123;&apos;names&apos;:&apos;BB&apos;,&apos;score&apos;:10,&apos;height&apos;:169&#125;, &#123;&apos;names&apos;:&apos;AA&apos;,&apos;score&apos;:80,&apos;height&apos;:179&#125;]print heapq.nsmallest(2,students,key=lambda x:x[&apos;height&apos;])]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>if/else</tag>
        <tag>code part</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post` bash$ hexo new “My New Post”` More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
</search>
